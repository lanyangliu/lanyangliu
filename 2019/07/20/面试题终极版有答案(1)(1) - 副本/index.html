<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lanyangliu.io/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lanyangliu.io/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lanyangliu.io/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lanyangliu.io/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/lanyangliu.io/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/lanyangliu.io/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/lanyangliu.io/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/lanyangliu.io/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/lanyangliu.io/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="interview,">










<meta name="description" content="概述：前端面试题汇总。">
<meta name="keywords" content="interview">
<meta property="og:type" content="article">
<meta property="og:title" content="前端面试题">
<meta property="og:url" content="https://github.com/lanyangliu/2019/07/20/面试题终极版有答案(1)(1) - 副本/index.html">
<meta property="og:site_name" content="刘兰阳">
<meta property="og:description" content="概述：前端面试题汇总。">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=2051579444,1975337901&fm=173&app=49&f=JPEG?w=640&h=336&s=E6F855CADEA1B364427D94190100C0C2">
<meta property="og:image" content="https://ss0.baidu.com/6ONWsjip0QIZ8tyhnq/it/u=2212009035,742952232&fm=173&app=49&f=JPEG?w=439&h=291&s=DAF877CA4AE6976C1EE94C1F0100C0C3">
<meta property="og:image" content="https://ss0.baidu.com/6ONWsjip0QIZ8tyhnq/it/u=2133644502,896555523&fm=173&app=49&f=JPEG?w=640&h=344&s=DAB851CA1BE1B76C1EC9BC16030010C2">
<meta property="og:image" content="https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=2041020946,1230706412&fm=173&app=49&f=JPEG?w=640&h=449&s=DEB651CADAEC836C1EC50C17010080C1">
<meta property="og:image" content="https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=2892674680,3034243458&fm=173&app=49&f=JPEG?w=640&h=43">
<meta property="og:image" content="https://ss0.baidu.com/6ONWsjip0QIZ8tyhnq/it/u=2804254824,408437685&fm=173&app=49&f=JPEG?w=640&h=287&s=277075320B22452014DD81DA0000C0B2">
<meta property="og:image" content="https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=1416847097,985428294&fm=173&app=49&f=JPEG?w=398&h=249&s=4591AC70EAE2641503A24E0F020040EE">
<meta property="og:updated_time" content="2019-07-26T12:40:58.272Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="前端面试题">
<meta name="twitter:description" content="概述：前端面试题汇总。">
<meta name="twitter:image" content="https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=2051579444,1975337901&fm=173&app=49&f=JPEG?w=640&h=336&s=E6F855CADEA1B364427D94190100C0C2">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/lanyangliu.io/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://github.com/lanyangliu/2019/07/20/面试题终极版有答案(1)(1) - 副本/">





  <title>前端面试题 | 刘兰阳</title>
  








</head>
<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/lanyangliu.io/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">刘兰阳</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-主页">
          <a href="/lanyangliu.io/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            主页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-关于">
          <a href="/lanyangliu.io/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-标签">
          <a href="/lanyangliu.io/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-类别">
          <a href="/lanyangliu.io/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            类别
          </a>
        </li>
      
        
        <li class="menu-item menu-item-档案">
          <a href="/lanyangliu.io/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            档案
          </a>
        </li>
      
        
        <li class="menu-item menu-item-安排">
          <a href="/lanyangliu.io/schedule/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br>
            
            安排
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/lanyangliu/lanyangliu.io/2019/07/20/面试题终极版有答案(1)(1) - 副本/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lanyangliu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/lanyangliu.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘兰阳">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">前端面试题</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-20T16:53:55+08:00">
                2019-07-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>概述：前端面试题汇总。</p>
<a id="more"></a>
<h1 id="Css"><a href="#Css" class="headerlink" title="Css"></a>Css</h1><h3 id="1、盒模型，标准，IE"><a href="#1、盒模型，标准，IE" class="headerlink" title="1、盒模型，标准，IE"></a>1、盒模型，标准，IE</h3><p>W3C定义的标准盒模型包括margin、border、padding、content，元素的宽度width=content的宽度，IE盒模型也包括margin、border、padding、content，元素的宽度width=border + padding + content</p>
<h3 id="2、flex布局，几种属性的作用"><a href="#2、flex布局，几种属性的作用" class="headerlink" title="2、flex布局，几种属性的作用"></a>2、flex布局，几种属性的作用</h3><p>Flex布局不会出现外边距合并问题，display:flex后它的所有子元素自动成为容器，任何一个容器都可以指定为flex布局，成员子元素的 ﬂoat、clear 和 vertical-align 属性将失效。要是有ul&gt;li的要给ul清除内外边距（margin:0;padding:0;）</p>
<ul>
<li><h6 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap:"></a>flex-wrap:</h6></li>
</ul>
<ul>
<li><h6 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content:"></a>justify-content:</h6><ul>
<li><h6 id="flex-start（默认值）：左对齐"><a href="#flex-start（默认值）：左对齐" class="headerlink" title="flex-start（默认值）：左对齐"></a><code>flex-start</code>（默认值）：左对齐</h6></li>
<li><p><code>flex-end</code>：右对齐</p>
</li>
<li><p><code>center</code>： 居中</p>
</li>
<li><p><code>space-between</code>：两端对齐，项目之间的间隔都相等</p>
</li>
<li><p><code>space-around</code>：每个子盒子两侧的间隔相等</p>
</li>
</ul>
</li>
<li><h6 id="align-items："><a href="#align-items：" class="headerlink" title="align-items："></a>align-items：</h6><ul>
<li><h6 id="flex-start：交叉轴的起点对齐"><a href="#flex-start：交叉轴的起点对齐" class="headerlink" title="flex-start：交叉轴的起点对齐"></a><code>flex-start</code>：交叉轴的起点对齐</h6></li>
<li><p><code>flex-end</code>：交叉轴的终点对齐</p>
</li>
<li><p><code>center</code>：交叉轴的中点对齐</p>
</li>
<li><p><code>baseline</code>: 项目的第一行文字的基线对齐</p>
</li>
<li><p><code>stretch</code>（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</p>
</li>
</ul>
</li>
</ul>
<h3 id="3、px为什么是双数"><a href="#3、px为什么是双数" class="headerlink" title="3、px为什么是双数"></a>3、px为什么是双数</h3><ol>
<li><p>美工方面: 设计图一般都采取双数的大小来设计</p>
</li>
<li><p>这样页面可以形成较好的比例关系</p>
</li>
<li><p>低版本IE会把单数自动转换为双数</p>
</li>
</ol>
<h3 id="4、css选择器有哪些-优先级"><a href="#4、css选择器有哪些-优先级" class="headerlink" title="4、css选择器有哪些?优先级"></a>4、css选择器有哪些?优先级</h3><ul>
<li>id选择器、类选择器、标签选择器、伪类选择器</li>
</ul>
<ol>
<li><p>后代选择器: 父代名 后代名 { 属性名:属性值; }</p>
</li>
<li><p>子代选择器: 父代名&gt;子代名 { 属性名:属性值; }</p>
</li>
<li><p>群组选择器: #name1, .name2, #name div { 属性名:属性值; }</p>
</li>
<li><p>伪类选择器: name:伪类</p>
</li>
<li><p>通用(通配符)选择器: * { 属性名: 属性值; }……</p>
</li>
</ol>
<ul>
<li>可继承的CSS属性：font-，text-，line-； </li>
<li>优先级：标签选择器 &lt; 类选择器 &lt; ID选择器 &lt; 内联 &lt; !important</li>
</ul>
<h3 id="5、什么是BFC"><a href="#5、什么是BFC" class="headerlink" title="5、什么是BFC"></a>5、什么是BFC</h3><p>在一个Web页面的CSS渲染中，块级格式化上下文 (Block Fromatting Context)是按照块级盒子布局的。W3C对BFC的定义如下：</p>
<p>浮动元素和绝对定位元素，非块级盒子的块级容器（例如 inline-blocks, table-cells, 和 table-captions），以及overflow值不为“visiable”的块级盒子，都会为他们的内容创建新的BFC（块级格式上下文）。</p>
<p>为了便于理解，我们换一种方式来重新定义BFC。一个HTML元素要创建BFC，则满足下列的任意一个或多个条件即可：</p>
<p>1、float的值不是none。<br>2、position的值不是static或者relative。<br>3、display的值是inline-block、table-cell、flex、table-caption或者inline-flex<br>4、overflow的值不是visible</p>
<p>BFC是一个独立的布局环境，其中的元素布局是不受外界的影响，并且在一个BFC中，块盒与行盒（行盒由一行中所有的内联元素所组成）都会垂直的沿着其父元素的边框排列。</p>
<h3 id="6、常见页面布局"><a href="#6、常见页面布局" class="headerlink" title="6、常见页面布局"></a>6、常见页面布局</h3><ul>
<li>流式布局</li>
<li>flex布局</li>
<li>响应式布局</li>
<li>rem布局</li>
</ul>
<h3 id="7、响应式布局，xs，sm，md，lg对应的分辨率"><a href="#7、响应式布局，xs，sm，md，lg对应的分辨率" class="headerlink" title="7、响应式布局，xs，sm，md，lg对应的分辨率"></a>7、响应式布局，xs，sm，md，lg对应的分辨率</h3><ul>
<li>col-xs-   超小屏幕 手机 (&lt;768px)</li>
<li>col-sm-  小屏幕 平板 (≥768px)</li>
<li>col-md-  中等屏幕 桌面显示器 (≥992px)<br> col-lg-    大屏幕 大桌面显示器 (≥1200px)    </li>
</ul>
<h3 id="8、css预处理器用过没，缺点是是什么，好处是什么"><a href="#8、css预处理器用过没，缺点是是什么，好处是什么" class="headerlink" title="8、css预处理器用过没，缺点是是什么，好处是什么"></a>8、css预处理器用过没，缺点是是什么，好处是什么</h3><ul>
<li>less</li>
</ul>
<ol>
<li>缺点：<ul>
<li>需要安装插件</li>
<li>需要学习特定的语法</li>
<li>需要编译</li>
</ul>
</li>
<li>好处：<ul>
<li>减少了传统的样式书写的冗余问题</li>
<li>可以添加变量和数学计算</li>
<li>增加样式书写的速度<h3 id="9、css3新特性有哪些？说个4-5个"><a href="#9、css3新特性有哪些？说个4-5个" class="headerlink" title="9、css3新特性有哪些？说个4-5个"></a>9、css3新特性有哪些？说个4-5个</h3></li>
</ul>
</li>
</ol>
<p>​    box-shadow  盒子阴影</p>
<p>​    transform    ，rotate（旋转）、translate（移动）</p>
<p>​    border-redius   圆角</p>
<p>​    nth-child   结构伪类选择器</p>
<p>​    <strong>animate</strong>  动画</p>
<p>​            name：所用的动画的名称</p>
<p>​            duration：动画持续的时间</p>
<p>​            timing-function： 动画的类型</p>
<p>​            delay： 动画延迟时间</p>
<p>​            derection： 动画在循环中是否反向运功</p>
<p>​            fill-mode：动画时间之外的状态</p>
<p>​    <strong>transtion</strong>：过渡动画 </p>
<p>​            property：参与的过渡的属性</p>
<p>​            duration：过渡持续的时间</p>
<p>​            timing-function： 过渡的动画类型</p>
<p>​            delay： 延迟过渡的时间</p>
<h3 id="10、display和visbility区别"><a href="#10、display和visbility区别" class="headerlink" title="10、display和visbility区别"></a>10、display和visbility区别</h3><ul>
<li>display 隐藏元素后不会占用位置</li>
<li>visibility 隐藏元素后位置保留</li>
</ul>
<h3 id="11、相邻的两个inline-block节点为什么会出现间隔，该如何解决"><a href="#11、相邻的两个inline-block节点为什么会出现间隔，该如何解决" class="headerlink" title="11、相邻的两个inline-block节点为什么会出现间隔，该如何解决"></a>11、相邻的两个inline-block节点为什么会出现间隔，该如何解决</h3><ul>
<li>清除浮动</li>
</ul>
<h3 id="12、rem布局的优缺点"><a href="#12、rem布局的优缺点" class="headerlink" title="12、rem布局的优缺点"></a>12、rem布局的优缺点</h3><p><strong>缺点：</strong> </p>
<ul>
<li><p>局限性; rem目前ie不支持 对pc页面来讲使用次数不多；</p>
</li>
<li><p>数据量大：所有的图片，盒子都需要我们去给一个准确的值；才能保证不同机型的适配；</p>
</li>
</ul>
<p><strong>优点：</strong> </p>
<ul>
<li><p>可以在 不同宽度的设备中变化页面元素的大小来适配设备的宽度达到最佳的显示效果</p>
</li>
<li><p>一般配合淘宝出的flexble.js来使用效果更好,没有媒体查询那么繁琐</p>
</li>
</ul>
<h3 id="13、CSS画三角形"><a href="#13、CSS画三角形" class="headerlink" title="13、CSS画三角形"></a>13、CSS画三角形</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">           <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">           <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">           <span class="attribute">border-width</span>: <span class="number">100px</span>;</span><br><span class="line">           <span class="attribute">border-style</span>: solid;</span><br><span class="line">           <span class="attribute">border-color</span>: <span class="number">#f00</span> transparent transparent transparent;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<h3 id="14、1像素边框问题"><a href="#14、1像素边框问题" class="headerlink" title="14、1像素边框问题"></a>14、1像素边框问题</h3><ul>
<li><h6 id="box-shadow-实现"><a href="#box-shadow-实现" class="headerlink" title="box-shadow 实现"></a>box-shadow 实现</h6></li>
</ul>
<p>利用阴影我们也可以实现，那么我们来看看阴影，优点是圆角不是问题，缺点是颜色不好控制。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">-webkit-box-shadow</span>:<span class="number">0</span> <span class="number">1px</span> <span class="number">1px</span> -<span class="number">1px</span> <span class="built_in">rgba</span>(0, 0, 0, 0.5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><h6 id="transform-scale-0-5-实现-推荐相当灵活"><a href="#transform-scale-0-5-实现-推荐相当灵活" class="headerlink" title="transform: scale(0.5) 实现 推荐相当灵活"></a>transform: scale(0.5) 实现 <code>推荐相当灵活</code></h6><p> 其实我们刚才列举了那么多例子，无非就是把1px缩放都0.5px的状态下，而0.5px并不是所有都支持，再根据媒体查询设置不同的缩放比例就可以了，那么我们就开始玩儿缩放吧。</p>
<p> <strong>1.用height：1px的div，然后根据媒体查询设置transform: scaleY(0.5);，</strong></p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">    height:1px;</span><br><span class="line">    background:#000;</span><br><span class="line">    -webkit-transform: scaleY(0.5);</span><br><span class="line">    -webkit-transform-origin:0 0;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>2.用::after和::befor,设置border-bottom：1px solid #000,然后在缩放-webkit-transform: scaleY(0.5);可以实现两根边线的需求</strong></p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">div::after&#123;</span><br><span class="line">    content:&apos;&apos;;width:100%;</span><br><span class="line">    border-bottom:1px solid #000;</span><br><span class="line">    transform: scaleY(0.5);&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>3.用::after设置border：1px solid #000; width:200%; height:200%,然后再缩放scaleY(0.5); 优点可以实现圆角，京东就是这么实现的，缺点是按钮添加active比较麻烦。</strong></p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.div::after &#123;</span><br><span class="line">    content: &apos;&apos;;</span><br><span class="line">    width: 200%;</span><br><span class="line">    height: 200%;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 0;</span><br><span class="line">    left: 0;</span><br><span class="line">    border: 1px solid #bfbfbf;</span><br><span class="line">    border-radius: 4px;</span><br><span class="line">    -webkit-transform: scale(0.5,0.5);</span><br><span class="line">    transform: scale(0.5,0.5);</span><br><span class="line">    -webkit-transform-origin: top left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="html"><a href="#html" class="headerlink" title="html"></a>html</h1><h3 id="1、语义化"><a href="#1、语义化" class="headerlink" title="1、语义化"></a>1、语义化</h3><ul>
<li>就是用一些特殊意义的单词来来表一些标签的用途,可以使结构更加清晰便于理解</li>
</ul>
<p><strong>为什么要语义化:</strong> </p>
<ol>
<li>没有语义化之前,布局基本都是div+ css,标签没有语义化,结构不清晰,不便于我们程序员理解</li>
<li>有利于搜索引擎的搜索和爬虫抓取有效的信息</li>
<li>方便其他设备解析,以语义 方式来渲染网页</li>
<li>便于团队开发维护,有利于规范化</li>
</ol>
<h3 id="2、新标签新特性"><a href="#2、新标签新特性" class="headerlink" title="2、新标签新特性"></a>2、新标签新特性</h3><ul>
<li>结构标签:    <ul>
<li>header: 页眉(头部,顶部,导航区域)</li>
<li>footer : 页脚(底部,版权区)</li>
<li>section: 定义一个区域</li>
<li>srticle:定义一篇文章</li>
<li>nav: 导航</li>
<li>aside: 侧边栏</li>
</ul>
</li>
<li>表单: <ul>
<li>date : 日期</li>
<li>time: 事件</li>
<li>email: 邮箱</li>
<li>search : 搜索</li>
</ul>
</li>
</ul>
<h3 id="3、处理过哪些兼容性问题"><a href="#3、处理过哪些兼容性问题" class="headerlink" title="3、处理过哪些兼容性问题"></a>3、处理过哪些兼容性问题</h3><ul>
<li><p>简单的 : </p>
<ul>
<li>浏览器之间padding和margin不统一 (默认清除内外边距,自己设定)</li>
<li>图片下面有一像素的的间距 (  vertical-align: middle )​</li>
</ul>
</li>
<li><p>移动端:</p>
<ul>
<li>300毫秒延迟问题 ( 1. mate标签禁用用户缩放user-scalable=0, 2. )</li>
</ul>
</li>
</ul>
<h3 id="4、做过哪些性能优化"><a href="#4、做过哪些性能优化" class="headerlink" title="4、做过哪些性能优化"></a>4、做过哪些性能优化</h3><ul>
<li>减少 HTTP 请求减少 DOM 元素数量；</li>
<li>css和js代码引用外联式；</li>
<li>压缩代码；</li>
<li>脚本放到 HTML 代码页底部，移除重复脚本</li>
<li>优化图片不要在 HTML 中使用缩放图片使用恰当的图片格式使用 CSSSprites (精灵图)技巧对图片优化</li>
</ul>
<h1 id="js"><a href="#js" class="headerlink" title="js"></a>js</h1><h3 id="1、原型-原型链-构造函数-实例-继承"><a href="#1、原型-原型链-构造函数-实例-继承" class="headerlink" title="1、原型/原型链/构造函数/实例/继承"></a>1、原型/原型链/构造函数/实例/继承</h3><ul>
<li><p><strong>原型:</strong> 当我们每创建一个函数,该函数有一个默认的prototype属性,它是一个指针,指向一个对象,这个对象就是原型</p>
</li>
<li><p><strong>原型链</strong>就是当我们使用一个属性或者方法时,在构造函数中去查找,如果查找不到就到原型中查找,原型中查找不到就到原型的原型中查找,如果还查找不到就返回null</p>
</li>
<li><p><strong>构造函数的特点:</strong></p>
<ul>
<li><p>函数名首字母大写(区分普通函数)</p>
</li>
<li><p>通过this给对象添加属性和方法</p>
</li>
<li><p>使用New来生成实例</p>
</li>
</ul>
<p><strong><em>含义:</em></strong>构造函数其实就是一个创建初始化对象的一个模板,它可以为实例对象默认初始化一些属性和方法</p>
</li>
<li><p><strong>实例:</strong> </p>
<ul>
<li>实例对象是由new 构造函数创建的, 它的<strong>proto</strong>指向原型对象,constructor属性指向它的构造函数</li>
</ul>
</li>
<li><p><strong>继承:</strong> </p>
<ul>
<li>继承原有对象的属性和方法,或者添加一些新的属性和方法得到一个新对象;不影响原有对象</li>
</ul>
</li>
</ul>
<h3 id="2、有几种方式可以实现继承"><a href="#2、有几种方式可以实现继承" class="headerlink" title="2、有几种方式可以实现继承"></a>2、有几种方式可以实现继承</h3><ul>
<li><p>常用的方法:</p>
<ul>
<li>构造函数继承</li>
<li>原型继承</li>
<li>组合继承</li>
</ul>
</li>
</ul>
<h3 id="3、用原型实现继承有什么缺点，怎么解决"><a href="#3、用原型实现继承有什么缺点，怎么解决" class="headerlink" title="3、用原型实现继承有什么缺点，怎么解决"></a>3、用原型实现继承有什么缺点，怎么解决</h3><ul>
<li><p>原型继承的新对象改变其属性后,原有的对象也会跟着改变</p>
</li>
<li><p>使用组合继承,生成新对象的同时,添加或者改变属性和方法,原有的对象不会产生影响</p>
</li>
</ul>
<h3 id="4、arguments是什么？怎么用"><a href="#4、arguments是什么？怎么用" class="headerlink" title="4、arguments是什么？怎么用"></a>4、arguments是什么？怎么用</h3><ul>
<li><p>它是函数参数的一个集合,以伪数组的方式存储着数据</p>
</li>
<li><p>使用里面的那个数据,只需要使用arguments[数据下标]接口得到该数据</p>
</li>
<li><p>arguments可以使用length属性,如果想使用普通数组的其他常用属性需要转换为普通数组</p>
</li>
<li><p><strong>Array.prototype.slice.apply(arguments)</strong></p>
</li>
</ul>
<h3 id="5、判断对象，数组，基本数据类型"><a href="#5、判断对象，数组，基本数据类型" class="headerlink" title="5、判断对象，数组，基本数据类型"></a>5、判断对象，数组，基本数据类型</h3><ul>
<li><p>基本数据类型使用typeof来查看数据类型</p>
</li>
<li><p>引用数据类型(复杂)使用 Object.prototype.toString.call( )</p>
</li>
<li><p>Array.isArray()判断数组</p>
</li>
</ul>
<h3 id="6、作用域链、闭包、作用域"><a href="#6、作用域链、闭包、作用域" class="headerlink" title="6、作用域链、闭包、作用域"></a>6、作用域链、闭包、作用域</h3><ul>
<li><p><strong>作用域链:</strong> 当我们使用一个需要使用一个变量时,先在当前作用域查找,如果查找不到就到外层作用域查找,一直往外找,到window如果还找不到报错</p>
</li>
<li><p><strong>闭包:</strong> 在一个函数作用域访问另一个函数作用域的变量,此时会产生闭包</p>
</li>
<li><p><strong>作用域:</strong> </p>
<ul>
<li>作用域是可访问变量的集合。</li>
<li>在函数内部设置变量,该变量就只能在函数内部作用域使用</li>
<li>全局作用域: 在该作用域下设置的变量,属性和方法在任意的位置都可以使用访问</li>
<li>js中没有块级作用域</li>
</ul>
</li>
</ul>
<h3 id="7、Ajax的原生写法"><a href="#7、Ajax的原生写法" class="headerlink" title="7、Ajax的原生写法"></a>7、Ajax的原生写法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 一、创建异步对象</span><br><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">// 二、请求行</span><br><span class="line">// get</span><br><span class="line">xhr.open(&apos;get&apos;,&apos;123.php?username=&apos;+name);</span><br><span class="line">// post</span><br><span class="line">xhr.open(&apos;post&apos;,&apos;123.php&apos;);</span><br><span class="line">// 三、请求头 post设置</span><br><span class="line">xhr.setRequestHeader(&apos;Content-type&apos;,&apos;application/x-www.form-urlencoded&apos;);</span><br><span class="line">// 四、请求体</span><br><span class="line">// get</span><br><span class="line">xhr.send(null);</span><br><span class="line">// post</span><br><span class="line">xhr.send(&quot;username=&quot;+name);</span><br><span class="line">// 五、请求响应</span><br><span class="line">xhr.onreadystatechange = function() &#123;</span><br><span class="line">    if(xhr.status == 200 &amp;&amp; xhr.readyState == 4) &#123;</span><br><span class="line">       console.log(xhr.responseText);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8、对象深拷贝、浅拷贝"><a href="#8、对象深拷贝、浅拷贝" class="headerlink" title="8、对象深拷贝、浅拷贝"></a>8、对象深拷贝、浅拷贝</h3><ul>
<li><h6 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝:"></a>深拷贝:</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JSON.parse(JSON.stringify(Obj))</span><br></pre></td></tr></table></figure>

<p>递归的方法</p>
<p>递归就是对每一层的数据都实现一次 <code>创建对象-&gt;对象赋值</code> 的操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function deepClone(initalObj, finalObj) &#123;    </span><br><span class="line">  var obj = finalObj || &#123;&#125;;    </span><br><span class="line">  for (var i in initalObj) &#123;        </span><br><span class="line">    if (typeof initalObj[i] === &apos;object&apos;) &#123;</span><br><span class="line">      obj[i] = (initalObj[i].constructor === Array) ? [] : &#123;&#125;;            </span><br><span class="line">      arguments.callee(initalObj[i], obj[i]);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      obj[i] = initalObj[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;    </span><br><span class="line">  return obj;</span><br><span class="line">&#125;</span><br><span class="line">var str = &#123;&#125;;</span><br><span class="line">var obj = &#123; a: &#123;a: &quot;hello&quot;, b: 21&#125; &#125;;</span><br><span class="line">deepClone(obj, str);</span><br><span class="line">console.log(str.a);</span><br></pre></td></tr></table></figure>
</li>
<li><h6 id="浅拷贝："><a href="#浅拷贝：" class="headerlink" title="浅拷贝："></a>浅拷贝：</h6><h6 id="for-in-遍历赋值"><a href="#for-in-遍历赋值" class="headerlink" title="for in 遍历赋值"></a>for in 遍历赋值</h6></li>
</ul>
<h3 id="9、图片懒加载原理"><a href="#9、图片懒加载原理" class="headerlink" title="9、图片懒加载原理"></a>9、图片懒加载原理</h3><ul>
<li>监听浏览器窗口,先把页面的img图片都替换成一张默认的图片;等到图片进入可视区,才将该图片的真是地址添加到src属性内,让图片显示出来</li>
</ul>
<h3 id="10、实现页面加载进度条"><a href="#10、实现页面加载进度条" class="headerlink" title="10、实现页面加载进度条"></a>10、实现页面加载进度条</h3><h3 id="11、this指向"><a href="#11、this指向" class="headerlink" title="11、this指向"></a>11、this指向</h3><p>this是一个关键字，它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。 </p>
<p>1.作为纯粹的函数调用 this指向全局对象 </p>
<p>2.作为对象的方法调用 this指向调用对象 </p>
<p>3.作为构造函数被调用 this指向新的对象（new会改变this的指向） </p>
<p>4.apply调用 this指向apply方法的第一个参数</p>
<h3 id="12、为什么会有同源策略"><a href="#12、为什么会有同源策略" class="headerlink" title="12、为什么会有同源策略"></a>12、为什么会有同源策略</h3><p>​    同域名、通接口、同协议</p>
<p>​    主要还是网络安全问题，因为有些网站会被别人模仿来制造钓鱼网站，同源策略就可以一定程度避免在浏览一个网站时被指引到一个假的网站内，造成数据被盗用等一系列的危害；如一些钓鱼网站</p>
<h3 id="13、怎么判断两个对象是否相等"><a href="#13、怎么判断两个对象是否相等" class="headerlink" title="13、怎么判断两个对象是否相等"></a>13、怎么判断两个对象是否相等</h3><p>1.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JSON.stringify(A)==JSON.stringify(B)(A和B为两个对像）；</span><br></pre></td></tr></table></figure>

<p>2.定义一个对象var  a={},判断a是否为空</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JSON.stringify(a) == &quot;&#123;&#125;&quot;；</span><br></pre></td></tr></table></figure>

<p>3.两个数组A和B如果想将B赋值给A，但是对A进行操作的时候B不变</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;a:&apos;a&apos;&#125;,obj1 = &#123;b:&apos;b&apos;&#125;,obj2 = &#123;a:&apos;a&apos;&#125;;</span><br></pre></td></tr></table></figure>

<p>就是使用<br>JSON.stringify()<br>先把对象转化成字符串，<br>这样就可以啦</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(JSON.stringify(obj) == JSON.stringify(obj1));//false</span><br><span class="line"></span><br><span class="line">console.log(JSON.stringify(obj)==JSON.stringify(obj2));//true)</span><br></pre></td></tr></table></figure>

<h3 id="14、事件委托是什么"><a href="#14、事件委托是什么" class="headerlink" title="14、事件委托是什么"></a>14、事件委托是什么</h3><p>通过某个元素来管理某一类型的事件，比如常用的就是在父元素身上进行事件委托，然后通过e.target来获取真正触发事件的元素Pson.addEventlistent(‘事件类型’,(e) =&gt; { e.target})</p>
<p>jquery中使用$(‘父元素’).on(‘事件类型’,’触发的对象’,callback)</p>
<h3 id="15、window的onload事件和domcontentloaded区别"><a href="#15、window的onload事件和domcontentloaded区别" class="headerlink" title="15、window的onload事件和domcontentloaded区别"></a>15、window的onload事件和domcontentloaded区别</h3><p>​    <strong>onload</strong> : 等到dom元素和外部引用的资源全部加载完成才会执行</p>
<p>​    <strong>domcontentloaded</strong>: dom元素加载完成就可以执行</p>
<h3 id="16、call-apply-bind区别"><a href="#16、call-apply-bind区别" class="headerlink" title="16、call  apply  bind区别"></a>16、call  apply  bind区别</h3><p>​    它们都可以改变this指向</p>
<p>​    <strong>call:</strong> 第二个参数和后面的参数可以穿任意类型的数据(自动调用函数)</p>
<p>​    <strong>apply:</strong> 第二个参数只能传入数组(自动调用函数)</p>
<p>​    <strong>bind:</strong> 不会调用函数</p>
<p>call() 、apply()可以看作是某个对象的方法，通过调用方法的形式来间接调用函数。bind() 就是将某个函数绑定到某个对象上。</p>
<p>​    <strong>call()**</strong>和<strong><strong>apply()</strong></strong>的区别就在于，两者之间的参数。都会改变<strong><strong>this</strong></strong>指向**</p>
<p>call()在第一个参数（this指向）之后的后续所有参数就是传入该函数的值（就是该函数的参数）。<strong>apply() **</strong>只有两个参数**，第一个是this对象，第二个是数组，这个数组就是该函数的参数。</p>
<p>bind() 方法和前两者不同在于： bind() 方法会返回执行上下文被改变的函数而不会立即执行，而前两者是直接执行该函数。他的参数和call()相同。</p>
<h3 id="17、async-await用过吗？ES7新语法"><a href="#17、async-await用过吗？ES7新语法" class="headerlink" title="17、async/await用过吗？ES7新语法"></a>17、async/await用过吗？ES7新语法</h3><p>​    <strong>async</strong>:作为一个关键字放在一个函数的前面,表示这个函数是一个异步函数</p>
<p>​    <strong>await</strong>: 指出现在异步函数中</p>
<h3 id="18、立即执行函数和使用场景"><a href="#18、立即执行函数和使用场景" class="headerlink" title="18、立即执行函数和使用场景"></a>18、立即执行函数和使用场景</h3><p>​    立即执行函数,顾名思义就是会自动立即执行的函数</p>
<p><strong>使用场景:</strong> </p>
<p>​        生成单独的作用域,可以封装一些外部无法读取的私有变量</p>
<p>​        防止全局变量污染</p>
<p>​        改变变量作用域</p>
<p>​    </p>
<h3 id="19、数组去重，至少说一种ES6新增方法"><a href="#19、数组去重，至少说一种ES6新增方法" class="headerlink" title="19、数组去重，至少说一种ES6新增方法"></a>19、数组去重，至少说一种ES6新增方法</h3><p>​    方法一</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">​</span><br><span class="line">javascript</span><br><span class="line">function uniq(array)&#123;</span><br><span class="line">    var temp = []; //一个新的临时数组</span><br><span class="line">    for(var i = 0; i &lt; array.length; i++)&#123;</span><br><span class="line">        if(temp.indexOf(array[i]) == -1)&#123; // 等于-1说明数组内没有该元素</span><br><span class="line">            temp.push(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    方法二</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">​         javascript</span><br><span class="line">/*</span><br><span class="line">* 给传入数组排序，排序后相同值相邻，</span><br><span class="line">* 然后遍历时,新数组只加入不与前一值重复的值。</span><br><span class="line">* 会打乱原来数组的顺序</span><br><span class="line">* */</span><br><span class="line">function uniq(array)&#123;</span><br><span class="line">    array.sort();</span><br><span class="line">    var temp=[array[0]];</span><br><span class="line">    for(var i = 1; i &lt; array.length; i++)&#123;</span><br><span class="line">        if( array[i] !== temp[temp.length-1])&#123; </span><br><span class="line">            temp.push(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法三,ES6</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">javascript</span><br><span class="line">function unique(arr)&#123;</span><br><span class="line">  var x = new Set(arr);</span><br><span class="line"> return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="20、BOM属性对象方法"><a href="#20、BOM属性对象方法" class="headerlink" title="20、BOM属性对象方法"></a>20、BOM属性对象方法</h3><p>​    window: </p>
<p>​            setTimeout()</p>
<p>​            setInterval()</p>
<p>​            alert()</p>
<p>​            console.log()</p>
<p>​    location: 保存着与当前文档有关的信息</p>
<p>​            .host : 域名</p>
<p>​            .href:  完整的url地址</p>
<p>​            .reload()  : 刷新当前页面</p>
<p>​            .search()  : 或者url地址中?后面的数据</p>
<p>​    history:  保存着用户上网的历史记录</p>
<p>​        方法:</p>
<p>​            go(数字): 数字为负后退一个记录,为正前进一个记录</p>
<p>​            back() : 后退一个记录</p>
<p>​            forward(): 前进一个记录</p>
<p>​            </p>
<h3 id="21、垃圾回收机制"><a href="#21、垃圾回收机制" class="headerlink" title="21、垃圾回收机制"></a>21、垃圾回收机制</h3><p>​    按照规定的时间间隔周期,找到js文件中不使用的变量或者函数,然后释放掉其占用的内存空间,</p>
<h3 id="22、JS执行机制"><a href="#22、JS执行机制" class="headerlink" title="22、JS执行机制"></a>22、JS执行机制</h3><p>​    将同步任务,放在主线程进行处理(形成一个执行栈),而异步事件则放入任务队列中,当主线程的事件处理完成,然后执行任务队列中异步任务;这是一个徐怒汉的过程,只要执行栈中没有同步任务了,就会去任务队列中查看有没有要执行的异步任务,这种运行机制也叫事件循环(Event  Loop)</p>
<h1 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h1><h3 id="1、声明-let、const、var区别"><a href="#1、声明-let、const、var区别" class="headerlink" title="1、声明 let、const、var区别"></a>1、声明 let、const、var区别</h3><p>ES6之前定义变量是用 var,var问题：</p>
<p>1.污染全局2.存在预解析问题</p>
<p>在es6中首先引出一个概念就是块级作用域，在es6中有2中新的定义变量，一种是let，一种是const；</p>
<p>let就跟之前var的用法一样，const是定义常量的（常量一般为对象）；</p>
<p>let相比var的好处：</p>
<p>1.具备块级作用域：</p>
<p>见到let就是块级作用域，在什么地方定义就只能在什么地方使用；</p>
<p>2.没有预解析</p>
<p>3.同一个作用域不能重复定义，只能重新赋值</p>
<p>4 for循环，for循环黎明的类似父级作用域，花括号里面的又是一个作用域，比如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for(let a = 0; a&lt;3; a++)&#123;</span><br><span class="line">           let a = &apos;abc&apos;;</span><br><span class="line">           console.log(a);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>const定义的变量是常量，不能修改，常用在以下地方：就是不让别人动你的代码的时候，还常常用在定义host，账号，密码等</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const ora = require(&apos;ora&apos;)</span><br><span class="line">const rm = require(&apos;rimraf&apos;)</span><br><span class="line">const path = require(&apos;path&apos;)</span><br><span class="line">const chalk = require(&apos;chalk&apos;)</span><br><span class="line">const webpack = require(&apos;webpack&apos;)</span><br><span class="line">const config = require(&apos;../config&apos;)</span><br><span class="line">const webpackConfig = require(&apos;./webpack.prod.conf&apos;)</span><br></pre></td></tr></table></figure>

<h3 id="2、解构赋值怎么用"><a href="#2、解构赋值怎么用" class="headerlink" title="2、解构赋值怎么用"></a>2、解构赋值怎么用</h3><p>1、使用数组成员对变量赋值时，优先使用解构赋值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const arr=[3,54,6,6];</span><br><span class="line"></span><br><span class="line">//这是不好的写法</span><br><span class="line">const first=arr[0];</span><br><span class="line">const second=arr[1];</span><br><span class="line"></span><br><span class="line">//最佳表示</span><br><span class="line">const [first,second]=arr;        //first:3  second:54</span><br></pre></td></tr></table></figure>

<p>2、函数的参数如果是对象的成员，优先使用解构赋值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function getFullName(user)&#123;</span><br><span class="line">   const firstName= user.firstName;</span><br><span class="line">   const lastName=user.lastName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//以上写法可以利用解构赋值优化      可优化成以下样式</span><br><span class="line"></span><br><span class="line">function getFullName(obj)&#123;</span><br><span class="line">   const &#123;firstName,lastName&#125;=obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//最佳写法如下：</span><br><span class="line">function getFullName(&#123;firstName,lastName&#125;)&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>3、如果函数返回多个值，优先使用对象的解构赋值，而不是数组的解构赋值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function processInput(input)&#123;</span><br><span class="line">   return [left,right,top,bottom];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//以上写法不利于以后添加值，以及更改返回值的顺序。</span><br><span class="line"></span><br><span class="line">//以对象的形式作为返回值，是最佳的，便于以后添加返回值，以及更改返回值的顺序。</span><br><span class="line"></span><br><span class="line">function processInput(input)&#123;</span><br><span class="line">   return &#123;left,right,top,bottom&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const &#123;left,right&#125;=processInput(input);</span><br></pre></td></tr></table></figure>

<p>总结：解构赋值是我们ES6里面新添加的一个特性，主要是用在从数组与对象中提取数据，直接对应的获取就ok了;比起ES5里面的获取数据要更加简洁，清晰易懂，还能达到减少代码量的目的。<br>4、由以上的分解，可清晰的了解到解构赋值分为两种：  数组解构  与   对象解构。</p>
<p>数组解构的深层嵌套：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const arrs = [</span><br><span class="line">                       &apos;simth&apos;, </span><br><span class="line">                       [&apos;Tom&apos;, &apos;Rose&apos;], </span><br><span class="line">                       [&apos;Tony&apos;, &apos;James&apos;]</span><br><span class="line">                    ];</span><br><span class="line"></span><br><span class="line">   // 数组解构赋值</span><br><span class="line">   const [firstName, [secondName, threeName], [fourName, fiveName]] = arrs;</span><br><span class="line">const arrs = [</span><br><span class="line">                       &apos;simth&apos;, </span><br><span class="line">                       [&apos;Tom&apos;, &apos;Rose&apos;], </span><br><span class="line">                       [&apos;Tony&apos;, &apos;James&apos;]</span><br><span class="line">                    ];</span><br><span class="line"></span><br><span class="line">   // 数组解构赋值</span><br><span class="line">   const [firstName, [secondName, threeName], [fourName, fiveName]] = arrs;</span><br><span class="line"></span><br><span class="line">   //上面的得到的结果值</span><br><span class="line">   // firstName = &apos;simth</span><br><span class="line">   // second = &apos;Tom&apos;</span><br><span class="line">   // threeName = &apos;Rose&apos;</span><br><span class="line">   // fourName = &apos;Tony&apos;</span><br><span class="line">   // fiveName = &apos;James&apos;</span><br></pre></td></tr></table></figure>

<p>5、利用数组解构深层次的解构一个值出来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 从该数组中提取 出Rose</span><br><span class="line">   const arrs = [</span><br><span class="line">                        &apos;simth&apos;, </span><br><span class="line">                        [[&apos;Tom&apos;, &apos;Rose&apos;], &apos;Steve&apos;], </span><br><span class="line">                        [&apos;Tony&apos;, &apos;James&apos;]</span><br><span class="line">                    ];</span><br><span class="line"></span><br><span class="line">   // Destructure</span><br><span class="line">   const [ , // 跳过 &apos;simth&apos;</span><br><span class="line">             [[ , // 跳过 &apos;Tom&apos;</span><br><span class="line">             Name // Rose 赋值给变量 &apos;Name&apos;</span><br><span class="line">         ]]] = arrs;</span><br><span class="line"></span><br><span class="line">   // 请注意：你也可以这样写</span><br><span class="line">   // const [, [[, Name ]]] = arrs;</span><br><span class="line"></span><br><span class="line">   // 输出 Name: rose</span><br><span class="line">  Name;</span><br></pre></td></tr></table></figure>

<p>6、除了以上的情况，还可以利用rest（…）操作符捕获所有剩下的数值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const arrs = [</span><br><span class="line">                       &apos;simth&apos;, </span><br><span class="line">                       [&apos;Tom&apos;, &apos;Rose&apos;], </span><br><span class="line">                       [&apos;Tony&apos;, &apos;James&apos;]</span><br><span class="line">                    ];</span><br><span class="line"></span><br><span class="line">   // 数组解构赋值</span><br><span class="line">   const [firstName, ...Names] = arrs;     //[...Names]=[[&apos;Tom&apos;,&apos;Rose&apos;],[&apos;Tony&apos;,&apos;James&apos;]];</span><br></pre></td></tr></table></figure>

<p>7、对象解构赋值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//简单的对象解构赋值</span><br><span class="line"></span><br><span class="line">const &#123;name:a&#125;=&#123;name:&apos;simth&apos;&#125;;</span><br><span class="line"></span><br><span class="line">//输出变量 a 为 simth。</span><br><span class="line"> // 创建对象，并在对象里提取多个属性值：</span><br><span class="line">  const obj = &#123;</span><br><span class="line">    ironMan: &apos;Tony Stark&apos;, </span><br><span class="line">    cap: &apos;Steve Rogers&apos;, </span><br><span class="line">    blackWidow: &apos;Natasha Romanoff&apos;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  // 解构对象进行单个的获取</span><br><span class="line">  const &#123; </span><br><span class="line">    ironMan: a, </span><br><span class="line">    cap: b, </span><br><span class="line">    blackWidow: c </span><br><span class="line">  &#125; = avengers;</span><br><span class="line"></span><br><span class="line">  // a = &apos;Tony Stark &apos;</span><br><span class="line">  // b = &apos;Steve Rogers&apos;</span><br><span class="line">  // c =&apos;Natasha Romanoff&apos;</span><br><span class="line"></span><br><span class="line">  // 输出 a:Tony Stark</span><br><span class="line">  a;</span><br></pre></td></tr></table></figure>

<h3 id="3、Promise的使用与实现"><a href="#3、Promise的使用与实现" class="headerlink" title="3、Promise的使用与实现"></a>3、Promise的使用与实现</h3><p>详见：<a href="https://www.cnblogs.com/whybxy/p/7645578.html" target="_blank" rel="noopener">https://www.cnblogs.com/whybxy/p/7645578.html</a></p>
<h3 id="4、箭头函数this指向问题、拓展运算符"><a href="#4、箭头函数this指向问题、拓展运算符" class="headerlink" title="4、箭头函数this指向问题、拓展运算符"></a>4、箭头函数this指向问题、拓展运算符</h3><p>箭头函数有几个使用注意点。</p>
<p>（1）函数体内的<code>this</code>对象，就是定义时所在的对象，而不是使用时所在的对象。</p>
<p>（2）不可以当作构造函数，也就是说，不可以使用<code>new</code>命令，否则会抛出一个错误。</p>
<p>（3）不可以使用<code>arguments</code>对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</p>
<p>（4）不可以使用<code>yield</code>命令，因此箭头函数不能用作 Generator 函数。</p>
<p>详见：<a href="https://www.cnblogs.com/lujunan/p/10191578.html" target="_blank" rel="noopener">https://www.cnblogs.com/lujunan/p/10191578.html</a></p>
<h3 id="5、map和set有没有用过，如何实现一个数组去重，map数据结构有什么优点？"><a href="#5、map和set有没有用过，如何实现一个数组去重，map数据结构有什么优点？" class="headerlink" title="5、map和set有没有用过，如何实现一个数组去重，map数据结构有什么优点？"></a>5、map和set有没有用过，如何实现一个数组去重，map数据结构有什么优点？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, 2, 2, 3, 4]</span><br><span class="line">function unique (arr) &#123;</span><br><span class="line">    return [...new Set(arr)]</span><br><span class="line">&#125;</span><br><span class="line">console.log(unique(arr)) // [1, 2, 3, 4]</span><br></pre></td></tr></table></figure>

<h3 id="6、ES6怎么编译成ES5"><a href="#6、ES6怎么编译成ES5" class="headerlink" title="6、ES6怎么编译成ES5"></a>6、ES6怎么编译成ES5</h3><h1 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h1><h3 id="1、输入url到展示页面过程发生了什么？"><a href="#1、输入url到展示页面过程发生了什么？" class="headerlink" title="1、输入url到展示页面过程发生了什么？"></a>1、输入url到展示页面过程发生了什么？</h3><p>​       1、浏览器的地址栏输入URL并按下回车。</p>
<p>　　2、浏览器查找当前URL是否存在缓存，并比较缓存是否过期。</p>
<p>　　3、DNS解析URL对应的IP。</p>
<p>　　4、根据IP建立TCP连接（三次握手）。</p>
<p>　　5、HTTP发起请求。</p>
<p>　　6、服务器处理请求，浏览器接收HTTP响应。</p>
<p>　　7、渲染页面，构建DOM树。</p>
<p>　　8、关闭TCP连接（四次挥手）。</p>
<h3 id="2、重绘与回流"><a href="#2、重绘与回流" class="headerlink" title="2、重绘与回流"></a>2、重绘与回流</h3><p>重绘(repaint): 当元素样式的改变不影响布局时，浏览器将使用重绘对元素进行更新，此时由于只需要UI层面的重新像素绘制，因此 损耗较少</p>
<p>回流(reflow): 当元素的尺寸、结构或触发某些属性时，浏览器会重新渲染页面，称为回流。此时，浏览器需要重新经过计算，计算后还需要重新页面布局，因此是较重的操作。会触发回流的操作:</p>
<ul>
<li><p>页面初次渲染</p>
</li>
<li><p>浏览器窗口大小改变</p>
</li>
<li><p>元素尺寸、位置、内容发生改变</p>
</li>
<li><p>元素字体大小变化</p>
</li>
<li><p>添加或者删除可见的 dom 元素</p>
</li>
<li><p>激活 CSS 伪类（例如：:hover）</p>
</li>
<li><p>查询某些属性或调用某些方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">* clientWidth、clientHeight、clientTop、clientLeft</span><br><span class="line"></span><br><span class="line">* offsetWidth、offsetHeight、offsetTop、offsetLeft</span><br><span class="line"></span><br><span class="line">* scrollWidth、scrollHeight、scrollTop、scrollLeft</span><br><span class="line"></span><br><span class="line">* getComputedStyle()</span><br><span class="line"></span><br><span class="line">* getBoundingClientRect()</span><br><span class="line"></span><br><span class="line">* scrollTo()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>回流必定触发重绘，重绘不一定触发回流。重绘的开销较小，回流的代价较高。</p>
<h3 id="3、函数防抖与节流"><a href="#3、函数防抖与节流" class="headerlink" title="3、函数防抖与节流"></a>3、函数防抖与节流</h3><p>函数防抖 debounce</p>
<p>原理：将若干函数调用合成为一次，并在给定时间过去之后，或者连续事件完全触发完成之后，调用一次(仅仅只会调用一次！！！！！！！！！！)。</p>
<p>举个栗子：滚动scroll事件，不停滑动滚轮会连续触发多次滚动事件，从而调用绑定的回调函数，我们希望当我们停止滚动的时，才触发一次回调，这时可以使用函数防抖。</p>
<p>函数节流 throttle</p>
<p>原理：当达到了一定的时间间隔就会执行一次；可以理解为是缩减执行频率</p>
<p>举个栗子：还是以scroll滚动事件来说吧，滚动事件是及其消耗浏览器性能的，不停触发。以我在项目中碰到的问题，移动端通过scroll实现分页，不断滚动，我们不希望不断发送请求，只有当达到某个条件，比如，距离手机窗口底部150px才发送一个请求，接下来就是展示新页面的请求，不停滚动，如此反复；这个时候就得用到函数节流。</p>
<h3 id="4、cookies、session、sessionStorage、localStorage区别"><a href="#4、cookies、session、sessionStorage、localStorage区别" class="headerlink" title="4、cookies、session、sessionStorage、localStorage区别"></a>4、cookies、session、sessionStorage、localStorage区别</h3><p>cookie和session</p>
<p>cookie和session都是用来跟踪浏览器用户身份的会话方式。</p>
<p>区别：</p>
<p>1、保持状态：cookie保存在浏览器端，session保存在服务器端</p>
<p>2、使用方式：</p>
<p>（1）cookie机制：如果不在浏览器中设置过期时间，cookie被保存在内存中，生命周期随浏览器的关闭而结束，这种cookie简称会话cookie。如果在浏览器中设置了cookie的过期时间，cookie被保存在硬盘中，关闭浏览器后，cookie数据仍然存在，直到过期时间结束才消失。</p>
<p>2）session机制：当服务器收到请求需要创建session对象时，首先会检查客户端请求中是否包含sessionid。如果有sessionid，服务器将根据该id返回对应session对象。如果客户端请求中没有sessionid，服务器会创建新的session对象，并把sessionid在本次响应中返回给客户端</p>
<p>·<br><strong>sessionStorage、localStorage 和 cookie 之间的区别</strong><br>共同点：都是保存在浏览器端，且同源的。</p>
<p>·    区别：cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递；cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下。存储大小限制也不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。</p>
<p>·    而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。</p>
<p>·    数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。</p>
<p>·    作用域不同，sessionStorage<strong>不在</strong>不同的浏览器窗口中共享，即使是同一个页面；localStorage在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。Web Storage 支持事件通知机制，可以将数据更新的通知发送给监听者。Web Storage 的 api 接口使用更方便。</p>
<h3 id="5、浏览器内核"><a href="#5、浏览器内核" class="headerlink" title="5、浏览器内核"></a>5、浏览器内核</h3><p>(1)Trident内核，由于被微软采用，并得益于微软操作系统的普及，以前几乎一统天下，所以又称为“IE内核”，主要浏览器有IE系列浏览器；</p>
<p>(2)Gecko内核，因为被Mozilla FireFox浏览器采用并得到开发者的进一步丰富，又被称为“Firefox内核”；</p>
<p>(3)WebKit内核，是Safari浏览器使用的内核，由Apple研发。 Google Chrome、Opera及各种国产浏览器高速模式也使用Webkit作为内核。</p>
<p>(4)Blink内核，由Google和Opera Software共同开发的浏览器内核，现在Chrome（28及往后版本）、Opera（15及往后版本）都将Webkit内核换成了Blink内核。</p>
<h1 id="服务端与网络"><a href="#服务端与网络" class="headerlink" title="服务端与网络"></a><strong>服务端与网络</strong></h1><h3 id="1、常见状态码"><a href="#1、常见状态码" class="headerlink" title="1、常见状态码"></a>1、常见状态码</h3><table>
<thead>
<tr>
<th><strong>Type</strong></th>
<th><strong>Reason-phrase</strong></th>
<th><strong>Note</strong></th>
</tr>
</thead>
<tbody><tr>
<td>1XX</td>
<td>Informational</td>
<td>信息性状态码，表示接受的请求正在处理</td>
</tr>
<tr>
<td>2XX</td>
<td>Success</td>
<td>成功状态码，表示请求正常处理完毕</td>
</tr>
<tr>
<td>3XX</td>
<td>Redirection</td>
<td>重定向状态码，表示需要客户端需要进行附加操作</td>
</tr>
<tr>
<td>4XX</td>
<td>Client Error</td>
<td>客户端错误状态码，表示服务器无法处理请求</td>
</tr>
<tr>
<td>5XX</td>
<td>Server Error</td>
<td>服务器错误状态码，表示服务器处理请求出错</td>
</tr>
</tbody></table>
<p>200 返回正常</p>
<p>304 服务端资源无变化，可使用缓存资源</p>
<p>400 请求参数不合法</p>
<p>401 未认证</p>
<p>403 服务端禁止访问该资源</p>
<p>404 服务端未找到该资源</p>
<p>500 服务端异常</p>
<h3 id="2、缓存"><a href="#2、缓存" class="headerlink" title="2、缓存"></a>2、缓存</h3><p>400,401,403状态码分别代表什么</p>
<p>​     在http协议中的错误代码是没有402的，402是预留的类似比特币之类的支付错误编码<br>​     其他几项如下:<br>​     401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。<br>​     403 （禁止） 服务器拒绝请求。<br>​     404 （未找到） 服务器找不到请求的网页。</p>
<p>浏览器缓存，如何实现不通过缓存直接向服务器拿数据</p>
<h3 id="3、cookie-session-token"><a href="#3、cookie-session-token" class="headerlink" title="3、cookie, session, token"></a>3、cookie, session, token</h3><p>.cookie的特点：</p>
<ol>
<li><p>cookie是一门客户端缓存技术</p>
</li>
<li><p>cookie数据由服务器生成，发送给浏览器保存</p>
</li>
<li><p>cookie数据的格式：键值对</p>
</li>
<li><p>cookie数据过期机制：设置expire值</p>
</li>
<li><p>session是一门服务端会话缓存技术。</p>
</li>
<li><p>session由服务器端的web容器创建，保存在服务器端。</p>
</li>
<li><p>session保存数据：键值对形式</p>
</li>
<li><p>session过期：默认30分钟</p>
</li>
</ol>
<p>app项目为例：<br>一般app项目都会基于一个token做鉴权。<br>因为此时客户端不是浏览器，因此就没有cookie这一说了。<br>当用户登录app时，服务器会响应回来一个token信息（一般都是返回的一串唯一的标识符，比如说uuid或其他）。<br>服务器端会将登录用户跟token（票据）保存一个映射关系，一般保存在redis或者表里面，服务器端响应回来的token会缓存在手机</p>
<h3 id="4、cdn托管是什么"><a href="#4、cdn托管是什么" class="headerlink" title="4、cdn托管是什么"></a>4、cdn托管是什么</h3><p>CDN的全称是Content Delivery Network，即内容分发网络。CDN的基本原理是广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中，在用户访问网站时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应用户请求。</p>
<p>简单的来说，就是把原服务器上数据复制到其他服务器上，用户访问时，那台服务器近访问到的就是那台服务器上的数据。</p>
<h3 id="5、get-post区别"><a href="#5、get-post区别" class="headerlink" title="5、get post区别"></a>5、get post区别</h3><p>1、url可见性：</p>
<p>get，参数url可见；</p>
<p>post，url参数不可见</p>
<p>2、数据传输上：</p>
<p>get，通过拼接url进行传递参数；</p>
<p>post，通过body体传输参数</p>
<p>3、缓存性：</p>
<p>get请求是可以缓存的</p>
<p>post请求不可以缓存</p>
<p>4、后退页面的反应</p>
<p>get请求页面后退时，不产生影响</p>
<p>post请求页面后退时，会重新提交请求</p>
<p>5、传输数据的大小</p>
<p>get一般传输数据大小不超过2k-4k（根据浏览器不同，限制不一样，但相差不大）</p>
<p>post请求传输数据的大小根据php.ini 配置文件设定，也可以无限大。</p>
<p>6、安全性</p>
<p>这个也是最不好分析的，原则上post肯定要比get安全，毕竟传输参数时url不可见，但也挡不住部分人闲的没事在那抓包玩。安全性个人觉得是没多大区别的，防君子不防小人就是这个道理。对传递的参数进行加密，其实都一样。</p>
<h3 id="6、tcp三次握手，四次挥手流程"><a href="#6、tcp三次握手，四次挥手流程" class="headerlink" title="6、tcp三次握手，四次挥手流程"></a>6、tcp三次握手，四次挥手流程</h3><p>书中的例子是这样的，“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接</p>
<p>假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”。主要目的防止server端一直等待，浪费资源。</p>
<p>为什么建立连接是三次握手，而关闭连接却是四次挥手呢？</p>
<p>这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN<strong>放在一个报文里</strong>发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。****</p>
<p>在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。<br>第一次握手：建立连接时，客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；<br>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态； </p>
<p>第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。 完成三次握手，客户端与服务器开始传送数据.</p>
<p>​      四次分手：</p>
<p>（1）客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送（报文段4）。</p>
<p>（2）服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1（报文段5）。和SYN一样，一个FIN将占用一个序号。</p>
<p>（3）服务器B关闭与客户端A的连接，发送一个FIN给客户端A（报文段6）。</p>
<p>（4）客户端A发回ACK报文确认，并将确认序号设置为收到序号加1（报文段7）。</p>
<h3 id="7、跨域有几种？"><a href="#7、跨域有几种？" class="headerlink" title="7、跨域有几种？"></a>7、跨域有几种？</h3><p>JavaScript出于安全方面的考虑，不允许跨域调用其他页面的对象，<strong>当协议、子域名、主域名、端口号中任意一个不相同时，都算作不同域****</strong></p>
<h5 id="1-JSONP原理"><a href="#1-JSONP原理" class="headerlink" title="1.JSONP原理"></a>1.JSONP原理</h5><p>利用 <code>&lt;script&gt;</code> 元素的这个开放策略，网页可以得到从其他来源动态产生的 JSON 数据</p>
<h5 id="1-CORS原理"><a href="#1-CORS原理" class="headerlink" title="1.CORS原理"></a>1.CORS原理</h5><p>整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。<strong>因此，实现**</strong>CORS<strong><strong>通信的关键是服务器。只要服务器实现了</strong></strong>CORS<strong>**接口，就可以跨源通信</strong>。</p>
<h4 id="处理跨域方法三——WebSocket"><a href="#处理跨域方法三——WebSocket" class="headerlink" title="处理跨域方法三——WebSocket"></a>处理跨域方法三——WebSocket</h4><p>我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口</p>
<h4 id="处理跨域方法四——postMessage"><a href="#处理跨域方法四——postMessage" class="headerlink" title="处理跨域方法四——postMessage"></a>处理跨域方法四——postMessage</h4><p>HTML5为了解决这个问题，引入了一个全新的API：跨文档通信 API（Cross-documentmessaging）。这个API为window对象新增了一个 <code>window.postMessage</code> 方法，允许跨窗口通信，不论这两个窗口是否同源。****</p>
<h3 id="8、前端安全XSS、CSRF，了解一下"><a href="#8、前端安全XSS、CSRF，了解一下" class="headerlink" title="8、前端安全XSS、CSRF，了解一下"></a>8、前端安全XSS、CSRF，了解一下</h3><p>CSRF（Cross-siterequest forgery）：跨站请求伪造。</p>
<p>XSS（CrossSite Scripting）：跨域脚本攻击。</p>
<p>CSRF：是利用网站A本身的漏洞，去请求网站A的api。</p>
<p>XSS：是向网站 A 注入 JS代码，然后执行 JS 里的代码，篡改网站A的内容。****</p>
<h3 id="9、模块化，commonJS，es6，cmd，amd"><a href="#9、模块化，commonJS，es6，cmd，amd" class="headerlink" title="9、模块化，commonJS，es6，cmd，amd"></a>9、模块化，commonJS，es6，cmd，amd</h3><p>模块化是一种处理复杂系统分解为更好的可管理模块的方式，简化开发，一个模块就是实现特定功能的文件</p>
<p>CommonJS就是一个JavaScript模块化的规范，是用在服务器端的node的模块规范</p>
<p>AMD 即 Asynchronous  Module  Definition，中文名是“异步模块定义”的意思。它是一个在浏览器端模块化开发的规范</p>
<p>CMD规范是即一个js文件就是一个模块，是通过按需加载的方式，而不是必须在模块开始就加载所有的依赖。</p>
<p><strong>es6 **</strong>的<strong><strong>module</strong></strong>规范：<strong>模块功能主要由两个命令构成：</strong>export <strong>**和 import</strong>。</p>
<p><strong>export</strong>：用于规定模块的对外接口，</p>
<p><strong>import</strong>：用于输入其他模块提供的功能。</p>
<h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><h3 id="1、vue-单页面应用程序-和多页面应用程序的区别，优缺点"><a href="#1、vue-单页面应用程序-和多页面应用程序的区别，优缺点" class="headerlink" title="1、vue(单页面应用程序)和多页面应用程序的区别，优缺点"></a>1、vue(单页面应用程序)和多页面应用程序的区别，优缺点</h3><p>大雄：</p>
<p>答：只有一个HTML页面，通过路由实现页面内的蓉蓉切换，公共资源部分只加载一次，缺点是不利于seo（SEO就是一个网络优化）</p>
<h2 id="多页面应用程序就是咱们写的普通页面，通过a标签实现页面切换，每次切换页面都要重新加载公共资源部分"><a href="#多页面应用程序就是咱们写的普通页面，通过a标签实现页面切换，每次切换页面都要重新加载公共资源部分" class="headerlink" title="多页面应用程序就是咱们写的普通页面，通过a标签实现页面切换，每次切换页面都要重新加载公共资源部分"></a>多页面应用程序就是咱们写的普通页面，通过a标签实现页面切换，每次切换页面都要重新加载公共资源部分</h2><p>单页面应用程序：</p>
<p>只有一张Web页面的应用，是一种从Web服务器加载的富客户端，单页面跳转仅刷新局部资源 ，公共资源(js、css等)仅需加载一次，常用于PC端官网、购物等网站</p>
<p>多页面应用程序：</p>
<p>多页面跳转刷新所有资源，每个公共资源(js、css等)需选择性重新加载，常用于 app 或 客户端等</p>
<p>具体对比分析：</p>
<table>
<thead>
<tr>
<th>单页面应用（SinglePage Web Application，SPA）</th>
<th>多页面应用（MultiPage Application，MPA）</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>组成</td>
<td>一个外壳页面和多个页面片段组成</td>
<td>多个完整页面构成</td>
</tr>
<tr>
<td>资源共用(css,js)</td>
<td>共用，只需在外壳部分加载</td>
<td>不共用，每个页面都需要加载</td>
</tr>
<tr>
<td>刷新方式</td>
<td>页面局部刷新或更改</td>
<td>整页刷新</td>
</tr>
<tr>
<td>url 模式</td>
<td>a.com/#/pageone a.com/#/pagetwo</td>
<td>a.com/pageone.html a.com/pagetwo.html</td>
</tr>
<tr>
<td>用户体验</td>
<td>页面片段间的切换快，用户体验良好</td>
<td>页面切换加载缓慢，流畅度不够，用户体验比较差</td>
</tr>
<tr>
<td>转场动画</td>
<td>容易实现</td>
<td>无法实现</td>
</tr>
<tr>
<td>数据传递</td>
<td>容易</td>
<td>依赖 url传参、或者cookie 、localStorage等</td>
</tr>
<tr>
<td>搜索引擎优化(SEO)</td>
<td>需要单独方案、实现较为困难、不利于SEO检索 可利用服务器端渲染(SSR)优化</td>
<td>实现方法简易</td>
</tr>
<tr>
<td>试用范围</td>
<td>高要求的体验度、追求界面流畅的应用</td>
<td>适用于追求高度支持搜索引擎的应用</td>
</tr>
<tr>
<td>开发成本</td>
<td>较高，常需借助专业的框架</td>
<td>较低 ，但页面重复代码多</td>
</tr>
<tr>
<td>维护成本</td>
<td>相对容易</td>
<td>相对复杂</td>
</tr>
</tbody></table>
<p>单页面应用（SPA），通俗一点说就是指只有一个主页面的应用，浏览器一开始要加载所有必须的 html, js, css。所有的页面内容都包含在这个所谓的主页面中。但在写的时候，还是会分开写（页面片段），然后在交互的时候由路由程序动态载入，单页面的页面跳转，仅刷新局部资源。多应用于pc端。</p>
<p>多页面（MPA），就是指一个应用中有多个页面，页面跳转时是整页刷新</p>
<p>单页面的优点：</p>
<p>1，用户体验好，快，内容的改变不需要重新加载整个页面，基于这一点spa对服务器压力较小</p>
<p>2，前后端分离</p>
<p>3，页面效果会比较炫酷（比如切换页面内容时的专场动画）</p>
<p>单页面缺点：</p>
<p>1，不利于seo</p>
<p>2，导航不可用，如果一定要导航需要自行实现前进、后退。（由于是单页面不能用浏览器的前进后退功能，所以需要自己建立堆栈管理）</p>
<p>3，初次加载时耗时多</p>
<p>4，页面复杂度提高很多</p>
<p>详见：<a href="https://blog.csdn.net/ysh10086/article/details/89508685" target="_blank" rel="noopener">https://blog.csdn.net/ysh10086/article/details/89508685</a></p>
<h3 id="2、MVVM的理解"><a href="#2、MVVM的理解" class="headerlink" title="2、MVVM的理解"></a>2、MVVM的理解</h3><p>　MVVM 是Model-View-ViewModel 的缩写，它是一种基于前端开发的架构模式，其<strong>核心是提供对View 和 ViewModel 的双向数据绑定，这使得ViewModel 的状态改变可以自动传递给 View，即所谓的数据双向绑定</strong>。</p>
<p>　　Vue.js 是一个提供了 MVVM 风格的双向数据绑定的 Javascript 库，专注于View 层。它的核心是 MVVM 中的 VM，也就是 ViewModel。 ViewModel负责连接 View 和 Model，保证视图和数据的一致性，这种轻量级的架构让前端开发更加高效、便捷。</p>
<h3 id="3、如何实现一个自定义组件，不同组件之间如何通信的？"><a href="#3、如何实现一个自定义组件，不同组件之间如何通信的？" class="headerlink" title="3、如何实现一个自定义组件，不同组件之间如何通信的？"></a>3、如何实现一个自定义组件，不同组件之间如何通信的？</h3><p>1.如何实现一个自定义组件，不同组件之间如何通信？<br>组件需要注册后才可以使用，有全局注册和局部注册两种方式</p>
<p>在实例创建前通过</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">Vue.component(&apos;自定义标签名称&apos;,&#123;</span><br><span class="line">    //选项</span><br><span class="line">&#125;);</span><br><span class="line">var app = new Vue(&#123;</span><br><span class="line">    el:&apos;#app&apos;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>来注册全局组件，不必把每个组件都注册到全局，在实例中，使用components选项可以局部注册组件，注册后的组件只有在该实例作用域下有效，组件中也可以使用components选项来注册组件，使组件可以嵌套。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  var Child = &#123;</span><br><span class="line">      template:&apos;&lt;div&gt;局部注册组件内容&lt;/div&gt;&apos;</span><br><span class="line">&#125;</span><br><span class="line"> var app = new Vue(&#123;</span><br><span class="line">    el:&apos;#app&apos;,</span><br><span class="line">    components:&#123;</span><br><span class="line">        &apos;my-component&apos;:Child</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>组件关系可分为父子组件通信、兄弟组件通信、跨级组件通信</p>
<p>父子组件通信：</p>
<p>父组件向子组件通信，通过props传递数据</p>
<p>子组件向父组件传递数据时，用到自定义事件，子组件用$emit（）触发事件，父组件用$on（）监听子组件的事件，父组件也可以直接在子组件的自定义标签上使用v-on来监听</p>
<p>非父子组件通信</p>
<p>在Vue.js 1.x中，提供$dispatch()和$broadcast()两个方法。$dispatch()用于向上级派发事件，只要是它的父级（一级或多级以上），都可以在Vue实例的events选项内接收.$broadcast()由上级向下级广播事件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &#123;&#123;message&#125;&#125;</span><br><span class="line">    &lt;my-component&gt;&lt;/my-component&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;	</span><br><span class="line">    Vue.component(&apos;my-component&apos;,&#123;</span><br><span class="line">        template:&apos;&lt;button @click=&quot;event&quot;&gt;&lt;/button&gt;&apos;,</span><br><span class="line">    	methods:&#123;</span><br><span class="line">    		event:function() &#123;</span><br><span class="line">    			this.$dispatch(&apos;on-message&apos;,&apos;来自内部组件的数据&apos;);</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    var app = new Vue(&#123;</span><br><span class="line">        el:&apos;#app&apos;,</span><br><span class="line">        data:&#123;</span><br><span class="line">    	message:&apos;&apos;</span><br><span class="line">    	 &#125;,</span><br><span class="line">        events:&#123;</span><br><span class="line">    	&apos;on-message&apos;:function(msg) &#123;</span><br><span class="line">    	    this.message = msg;</span><br><span class="line">    			&#125;</span><br><span class="line">    	    &#125;</span><br><span class="line">    		</span><br><span class="line">    	&#125;)</span><br><span class="line">    &lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>但在Vue.js 2.x中都废弃了（不能解决兄弟组件通信问题）</p>
<p>在Vue.js 2.x中，推荐使用一个空的vue实例作为中央事件总线（bus），也就是一个中介</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">		&#123;&#123;message&#125;&#125;</span><br><span class="line">		&lt;component-a&gt;&lt;/component-a&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">	&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">	&lt;script&gt;</span><br><span class="line">		var bus = new Vue();</span><br><span class="line">		Vue.component(&apos;component-a&apos;,&#123;</span><br><span class="line">			template:&apos;&lt;button @click=&quot;event&quot;&gt;传递事件&lt;/button&gt;&apos;,</span><br><span class="line">			methods:&#123;</span><br><span class="line">				event:function() &#123;</span><br><span class="line">					bus.$emit(&apos;on-message&apos;,&apos;来自组件component-a的内容&apos;)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;)</span><br><span class="line">		var app = new Vue(&#123;</span><br><span class="line">			el:&apos;#app&apos;,</span><br><span class="line">			data:&#123;</span><br><span class="line">				message:&apos;&apos;</span><br><span class="line">			&#125;,</span><br><span class="line">			mounted: function() &#123;</span><br><span class="line">				var _this = this;</span><br><span class="line">				bus.$on(&apos;on-message&apos;,function(msg) &#123;</span><br><span class="line">					_this.message = msg;</span><br><span class="line">				&#125;)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;)</span><br><span class="line">	&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>这种方法实现了任何组件间的通信，如果深入使用，可以扩展bus实例，给它添加data、computed、methods等选项，这些都是可以公用的</p>
<p>除了bus外，还有两种方法可以实现组件间通信，父链和子组件索引</p>
<p>父链</p>
<p>在子组件中，使用this.$parent可以直接访问该组件的父实例或组件，父组件也可以通过this.$children访问它所有的子组件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">		&#123;&#123;message&#125;&#125;</span><br><span class="line">		&lt;component-a&gt;&lt;/component-a&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">	&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">	&lt;script&gt;</span><br><span class="line">		var bus = new Vue();</span><br><span class="line">		Vue.component(&apos;component-a&apos;,&#123;</span><br><span class="line">			template:&apos;&lt;button @click=&quot;event&quot;&gt;传递事件&lt;/button&gt;&apos;,</span><br><span class="line">			methods:&#123;</span><br><span class="line">				event:function() &#123;</span><br><span class="line">					//访问到父链后，可以做任何操作，比如直接修改数据</span><br><span class="line">					this.$parent.message = &quot;来自组件component-a的内容&quot;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;)</span><br><span class="line">		var app = new Vue(&#123;</span><br><span class="line">			el:&apos;#app&apos;,</span><br><span class="line">			data:&#123;</span><br><span class="line">				message:&apos;&apos;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;)</span><br><span class="line">	&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>父子组件最好还是通过 props和$emit来通信</p>
<h3 id="4、nextTick"><a href="#4、nextTick" class="headerlink" title="4、nextTick"></a>4、nextTick</h3><blockquote>
<p>在下次 <code>DOM</code> 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 <code>DOM</code>。</p>
</blockquote>
<p>获取更新后的<code>DOM</code>言外之意就是什么操作需要用到了更新后的<code>DOM</code>而不能使用之前的<code>DOM</code>或者使用更新前的<code>DOM</code>会出问题，所以就衍生出了这个获取更新后的    <code>DOM</code>的<code>Vue</code>方法。所以放在<code>Vue.nextTick()</code>回调函数中的执行的应该是会对<code>DOM</code>进行操作的 <code>js</code>代码，比如Swiper扩展包的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var swiper = new Swiper(&apos;.swiper-container&apos;, &#123;</span><br><span class="line">                    pagination: &apos;.swiper-pagination&apos;,</span><br><span class="line">                    nextButton: &apos;.swiper-button-next&apos;,</span><br><span class="line">                    prevButton: &apos;.swiper-button-prev&apos;,</span><br><span class="line">                    paginationClickable: true,</span><br><span class="line">                    spaceBetween: 30,</span><br><span class="line">                    centeredSlides: true,</span><br><span class="line">                    autoplay: 2500,</span><br><span class="line">                    autoplayDisableOnInteraction: false</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>什么时候需要用Vue.nextTick():</strong></p>
<ul>
<li>你在<code>Vue</code>生命周期的created()钩子函数进行的<code>DOM</code>操作一定要放在<code>Vue.nextTick()</code>的回调函数中。原因是什么呢，原因是在<code>created()</code>钩子函数执行的时候<code>DOM</code> 其实并未进行任何渲染，而此时进行<code>DOM</code>操作无异于徒劳，所以此处一定要将<code>DOM</code>操作的<code>js</code>代码放进<code>Vue.nextTick()</code>的回调函数中。与之对应的就是mounted钩子函数，因为该钩子函数执行时所有的<code>DOM</code>挂载和渲染都已完成，此时在该钩子函数中进行任何<code>DOM</code>操作都不会有问题 。</li>
<li>在数据变化后要执行的某个操作，当你设置 <code>vm.someData = &#39;new value&#39;</code>，<code>DOM</code>并不会马上更新，而是在异步队列被清除，也就是下一个事件循环开始时执行更新时才会进行必要的<code>DOM</code>更新。如果此时你想要根据更新的 <code>DOM</code> 状态去做某些事情，就会出现问题。。为了在数据变化之后等待 <code>Vue</code> 完成更新 <code>DOM</code> ，可以在数据变化之后立即使用 <code>Vue.nextTick(callback)</code> 。这样回调函数在 <code>DOM</code> 更新完成后就会调用。</li>
<li><strong>mounted 不会承诺所有的子组件也都一起被挂载</strong>。如果你希望等到整个视图都渲染完毕，可以用 <code>vm.$nextTick</code> 替换掉 <code>mounted</code>：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mounted: function () &#123;</span><br><span class="line">this.$nextTick(function () &#123;</span><br><span class="line"></span><br><span class="line">// Code that will run only after the</span><br><span class="line">// entire view has been rendered</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5、生命周期"><a href="#5、生命周期" class="headerlink" title="5、生命周期"></a>5、生命周期</h3><p>Vue实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载Dom、渲染→更新→渲染、销毁等一系列过程，我们称这是Vue的生命周期。通俗说就是Vue实例从创建到销毁的过程，就是生命周期。</p>
<p>每一个组件或者实例都会经历一个完整的生命周期，总共分为三个阶段：初始化、运行中、销毁。</p>
<ol>
<li>实例、组件通过new Vue() 创建出来之后会初始化事件和生命周期，然后就会执行beforeCreate钩子函数，这个时候，数据还没有挂载呢，只是一个空壳，无法访问到数据和真实的dom，一般不做操作</li>
<li>挂载数据，绑定事件等等，然后执行created函数，这个时候已经可以使用到数据，也可以更改数据,在这里更改数据不会触发updated函数，在这里可以在渲染前倒数第二次更改数据的机会，不会触发其他的钩子函数，一般可以在这里做初始数据的获取</li>
<li>接下来开始找实例或者组件对应的模板，编译模板为虚拟dom放入到render函数中准备渲染，然后执行beforeMount钩子函数，在这个函数中虚拟dom已经创建完成，马上就要渲染,在这里也可以更改数据，不会触发updated，在这里可以在渲染前最后一次更改数据的机会，不会触发其他的钩子函数，一般可以在这里做初始数据的获取</li>
<li>接下来开始render，渲染出真实dom，然后执行mounted钩子函数，此时，组件已经出现在页面中，数据、真实dom都已经处理好了,事件都已经挂载好了，可以在这里操作真实dom等事情…</li>
<li>当组件或实例的数据更改之后，会立即执行beforeUpdate，然后vue的虚拟dom机制会重新构建虚拟dom与上一次的虚拟dom树利用diff算法进行对比之后重新渲染，一般不做什么事儿</li>
<li>当更新完成后，执行updated，数据已经更改完成，dom也重新render完成，可以操作更新后的虚拟dom</li>
<li>当经过某种途径调用$destroy方法后，立即执行beforeDestroy，一般在这里做一些善后工作，例如清除计时器、清除非指令绑定的事件等等</li>
<li>组件的数据绑定、监听…去掉后只剩下dom空壳，这个时候，执行destroyed，在这里做善后工作也可以</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">        &lt;aaa&gt;&lt;/aaa&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    &lt;template id=&quot;aaa&quot;&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;p class=&quot;myp&quot;&gt;A组件&lt;/p&gt;</span><br><span class="line">            &lt;button @click=&quot;destroy&quot;&gt;destroy&lt;/button&gt;</span><br><span class="line">            &lt;input type=&quot;text&quot; v-model=&quot;msg&quot;&gt;</span><br><span class="line">            &lt;p&gt;msg:&#123;&#123;msg&#125;&#125;&lt;/p&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    //生命周期：初始化阶段 运行中阶段 销毁阶段</span><br><span class="line">    Vue.component(&quot;aaa&quot;,&#123;</span><br><span class="line">        template:&quot;#aaa&quot;,</span><br><span class="line">        data:function()&#123;</span><br><span class="line">            return &#123;msg:&apos;hello&apos;&#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        timer:null,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            destroy:function()&#123;</span><br><span class="line">                this.$destroy()//</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        beforeCreate:function()&#123;</span><br><span class="line">            console.log(&apos;beforeCreate:刚刚new Vue()之后，这个时候，数据还没有挂载呢，只是一个空壳&apos;)           </span><br><span class="line">            console.log(this.msg)//undefined</span><br><span class="line">            console.log(document.getElementsByClassName(&quot;myp&quot;)[0])//undefined</span><br><span class="line">        &#125;,</span><br><span class="line">        created:function()&#123;</span><br><span class="line">            console.log(&apos;created:这个时候已经可以使用到数据，也可以更改数据,在这里更改数据不会触发updated函数&apos;)</span><br><span class="line">            this.msg+=&apos;!!!&apos;</span><br><span class="line">            console.log(&apos;在这里可以在渲染前倒数第二次更改数据的机会，不会触发其他的钩子函数，一般可以在这里做初始数据的获取&apos;)</span><br><span class="line">            console.log(&apos;接下来开始找实例或者组件对应的模板，编译模板为虚拟dom放入到render函数中准备渲染&apos;)</span><br><span class="line">        &#125;,</span><br><span class="line">        beforeMount:function()&#123;</span><br><span class="line">            console.log(&apos;beforeMount：虚拟dom已经创建完成，马上就要渲染,在这里也可以更改数据，不会触发updated&apos;)</span><br><span class="line">            this.msg+=&apos;@@@@&apos;</span><br><span class="line">            console.log(&apos;在这里可以在渲染前最后一次更改数据的机会，不会触发其他的钩子函数，一般可以在这里做初始数据的获取&apos;)</span><br><span class="line">            console.log(document.getElementsByClassName(&quot;myp&quot;)[0])//undefined</span><br><span class="line">            console.log(&apos;接下来开始render，渲染出真实dom&apos;)</span><br><span class="line">        &#125;,</span><br><span class="line">        // render:function(createElement)&#123;</span><br><span class="line">        //     console.log(&apos;render&apos;)</span><br><span class="line">        //     return createElement(&apos;div&apos;,&apos;hahaha&apos;)</span><br><span class="line">        // &#125;,</span><br><span class="line">        mounted:function()&#123; </span><br><span class="line">            console.log(&apos;mounted：此时，组件已经出现在页面中，数据、真实dom都已经处理好了,事件都已经挂载好了&apos;)</span><br><span class="line">            console.log(document.getElementsByClassName(&quot;myp&quot;)[0])</span><br><span class="line">            console.log(&apos;可以在这里操作真实dom等事情...&apos;)</span><br><span class="line"></span><br><span class="line">        //    this.$options.timer = setInterval(function () &#123;</span><br><span class="line">        //        console.log(&apos;setInterval&apos;)</span><br><span class="line">        //         this.msg+=&apos;!&apos;  </span><br><span class="line">        //    &#125;.bind(this),500)</span><br><span class="line">        &#125;,</span><br><span class="line">        beforeUpdate:function()&#123;</span><br><span class="line">            //这里不能更改数据，否则会陷入死循环</span><br><span class="line">            console.log(&apos;beforeUpdate:重新渲染之前触发&apos;)</span><br><span class="line">            console.log(&apos;然后vue的虚拟dom机制会重新构建虚拟dom与上一次的虚拟dom树利用diff算法进行对比之后重新渲染&apos;)         </span><br><span class="line">        &#125;,</span><br><span class="line">        updated:function()&#123;</span><br><span class="line">            //这里不能更改数据，否则会陷入死循环</span><br><span class="line">            console.log(&apos;updated:数据已经更改完成，dom也重新render完成&apos;)</span><br><span class="line">        &#125;,</span><br><span class="line">        beforeDestroy:function()&#123;</span><br><span class="line">            console.log(&apos;beforeDestory:销毁前执行（$destroy方法被调用的时候就会执行）,一般在这里善后:清除计时器、清除非指令绑定的事件等等...&apos;)</span><br><span class="line">            // clearInterval(this.$options.timer)</span><br><span class="line">        &#125;,</span><br><span class="line">        destroyed:function()&#123;</span><br><span class="line">            console.log(&apos;destroyed:组件的数据绑定、监听...都去掉了,只剩下dom空壳，这里也可以善后&apos;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    new Vue(&#123;</span><br><span class="line">    &#125;).$mount(&apos;#app&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h3 id="6、虚拟dom的原理"><a href="#6、虚拟dom的原理" class="headerlink" title="6、虚拟dom的原理"></a>6、虚拟dom的原理</h3><p>Virual DOM是用JS对象记录一个dom节点的副本，当dom发生更改时候，先用<br>虚拟dom进行diff，算出最小差异，然后再修改真实dom。</p>
<p>vue的virtual dom的diff算法是基于snabbdom算法改造而来，与react的diff算法一样<br>仅在同级的vnode间做diff，递归的进行同级vnode的diff，最终实现整个DOM树的更新。</p>
<p>虚拟DOM的缺点：</p>
<p>\1. 代码更多，体积更大</p>
<p>\2. 内存占用增大</p>
<p>\3. 小量的单一的dom修改使用虚拟dom成本反而更高，不如直接修改真实dom快</p>
<h3 id="7、双向绑定的原理？"><a href="#7、双向绑定的原理？" class="headerlink" title="7、双向绑定的原理？"></a>7、双向绑定的原理？</h3><p>什么是双向数据绑定？Vue是一个MVVM框架，数据绑定简单来说，就是当数据发生变化时，相应的视图会进行更新，当视图更新时，数据也会跟着变化。</p>
<p>实现数据绑定的方式大致有以下几种：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 1、发布者-订阅者模式（backbone.js）</span><br><span class="line">- 2、脏值检查（angular.js）</span><br><span class="line">- 3、数据劫持（vue.js)</span><br></pre></td></tr></table></figure>

<h4 id="数据劫持"><a href="#数据劫持" class="headerlink" title="数据劫持"></a>数据劫持</h4><p>Vue.js则是通过数据劫持以及结合发布者-订阅者来实现的，数据劫持是利用ES5的Object.defineProperty(obj, key, val)来劫持各个属性的的setter以及getter，在数据变动时发布消息给订阅者，从而触发相应的回调来更新视图。</p>
<h3 id="8、组件通信"><a href="#8、组件通信" class="headerlink" title="8、组件通信"></a>8、组件通信</h3><p>​    父-&gt;子</p>
<p>父组件向子组件传递数据</p>
<p>子组件在父组件的并作为标签引入，通过设置标签的属性传递数据，在子组件用props接受，，例如下面这样，父组件parent.vue引入子组件child.vue，将父组件的数据name通过设置标签child的name属性传递给子组件，子组件通过props传递接受，接受后，在子组件内this.name就是父组件的name数据。</p>
<p><img src="https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=2051579444,1975337901&fm=173&app=49&f=JPEG?w=640&h=336&s=E6F855CADEA1B364427D94190100C0C2" alt="img">parent.vue</p>
<p><img src="https://ss0.baidu.com/6ONWsjip0QIZ8tyhnq/it/u=2212009035,742952232&fm=173&app=49&f=JPEG?w=439&h=291&s=DAF877CA4AE6976C1EE94C1F0100C0C3" alt="img">child.vue</p>
<p>​    子-&gt;父</p>
<p>子组件向父组件传递数据</p>
<p>1.发布订阅 发布 emit 订阅 on{}</p>
<p>2.on订阅，emit发布，on和emit是在Vue的原型上的，每个实例都可以调用。</p>
<p>3.父亲绑定一个事件，儿子触发这个事件，并将参数传递过去</p>
<p><img src="https://ss0.baidu.com/6ONWsjip0QIZ8tyhnq/it/u=2133644502,896555523&fm=173&app=49&f=JPEG?w=640&h=344&s=DAB851CA1BE1B76C1EC9BC16030010C2" alt="img">child.vue</p>
<p><img src="https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=2041020946,1230706412&fm=173&app=49&f=JPEG?w=640&h=449&s=DEB651CADAEC836C1EC50C17010080C1" alt="img">parent.vue</p>
<p>​    非父子组件</p>
<p>兄弟组件传递数据eventBus</p>
<p>同级传参或者隔级传参可以用eventBus（事件车），内部也是发布订阅模式实现的，适合于非常简单的小项目，一般不用(互相帮)中间键思想 :创建一个vue的实例,然后给每个子组件绑定一个方法(触发时候发布eventBus),在 每个子组件做一个订阅的监控,触发绑在created里的方法执行,靠传递参数的不同实现同步数据 (颜色)</p>
<p><img src="https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=2892674680,3034243458&fm=173&app=49&f=JPEG?w=640&h=43" alt="img"></p>
<p><img src="https://ss0.baidu.com/6ONWsjip0QIZ8tyhnq/it/u=2804254824,408437685&fm=173&app=49&f=JPEG?w=640&h=287&s=277075320B22452014DD81DA0000C0B2" alt="img"></p>
<p><img src="https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=1416847097,985428294&fm=173&app=49&f=JPEG?w=398&h=249&s=4591AC70EAE2641503A24E0F020040EE" alt="img">Vue</p>
<h3 id="10、watch-computed区别"><a href="#10、watch-computed区别" class="headerlink" title="10、watch   computed区别"></a>10、watch   computed区别</h3><p>watch顾名思义，用于监听数据变化，其中可以监听的数据来源有三部分：props、data、computed内的数据；watch提供两个参数（newValue，oldValue），第一个参数是新值，第二个参数保存旧值；</p>
<p>computed用于处理复杂的逻辑运算，主要和methods储存方法来进行区分；methods储存方法，，computed储存需要处理的数据值；methods每次都会调用，computed有缓存机制，只有改变时才执行，性能更佳；</p>
<p>computed是计算属性，是有依赖缓存的，只有在它的依赖发生改变时才会重新计算，这个计算出来的值，是可以直接当成data来用的，在用的时候不需要添加()，computed必须要有一个return值</p>
<h3 id="12、vue-router原理"><a href="#12、vue-router原理" class="headerlink" title="12、vue-router原理"></a>12、vue-router原理</h3><p>vue-router如何做用户登录权限等</p>
<p>你在项目中怎么实现路由的嵌套</p>
<h3 id="13、vuex的理解，有哪些属性？actions和mutations区别？"><a href="#13、vuex的理解，有哪些属性？actions和mutations区别？" class="headerlink" title="13、vuex的理解，有哪些属性？actions和mutations区别？"></a>13、vuex的理解，有哪些属性？actions和mutations区别？</h3><p>VueX 是一个专门为 Vue.js 应用设计的状态管理架构，统一管理和维护各个vue组件的可变化状态(你可以理解成 vue 组件里的某些 data )。</p>
<p>Vue有五个核心概念，<code>state</code>, <code>getters</code>, <code>mutations</code>, <code>actions</code>, <code>modules</code>。本文将对这个五个核心概念进行梳理。</p>
<p>state =&gt; 基本数据<br>getters =&gt; 从基本数据派生的数据<br>mutations =&gt; 提交更改数据的方法，同步！<br>actions =&gt; 像一个装饰器，包裹mutations，使之可以异步。<br>modules =&gt; 模块化Vuex</p>
<p>区别：</p>
<p> 区分 actions 和 mutations 并不是为了解决竞态问题，而是为了能用 devtools 追踪状态变化。</p>
<p>事实上在 vuex 里面 actions 只是一个架构性的概念，并不是必须的，说到底只是一个函数，你在里面想干嘛都可以，只要最后触发 mutation 就行。异步竞态怎么处理那是用户自己的事情。</p>
<p>vuex 真正限制你的只有 mutation 必须是同步的这一点（在 redux 里面就好像 reducer 必须同步返回下一个状态一样）。同步的意义在于这样每一个 mutation 执行完成后都可以对应到一个新的状态（和 reducer 一样），这样 devtools 就可以打个 snapshot 存下来，然后就可以随便 time-travel 了。如果你开着 devtool 调用一个异步的 action，你可以清楚地看到它所调用的 mutation 是何时被记录下来的，并且可以立刻查看它们对应的状态。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/lanyangliu.io/tags/interview/" rel="tag"><i class="fa fa-tag"></i> interview</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/lanyangliu.io/2019/07/16/图书管理案例（Vue）/" rel="next" title="图书管理案例">
                <i class="fa fa-chevron-left"></i> 图书管理案例
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/lanyangliu.io/2019/07/22/webpack/" rel="prev" title="webpack">
                webpack <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/lanyangliu.io/images/avatar.gif" alt="lanyangliu">
            
              <p class="site-author-name" itemprop="name">lanyangliu</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/lanyangliu.io/archives">
              
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/lanyangliu.io/tags/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/lanyangliu" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:185701642@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://weibo.com/u/3608268267/home?wvr=5&sudaref=login.sina.com.cn" target="_blank" title="微博">
                      
                        <i class="fa fa-fw fa-weibo"></i>微博</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Css"><span class="nav-number">1.</span> <span class="nav-text">Css</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、盒模型，标准，IE"><span class="nav-number">1.0.1.</span> <span class="nav-text">1、盒模型，标准，IE</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、flex布局，几种属性的作用"><span class="nav-number">1.0.2.</span> <span class="nav-text">2、flex布局，几种属性的作用</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#flex-wrap"><span class="nav-number">1.0.2.0.0.1.</span> <span class="nav-text">flex-wrap:</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#justify-content"><span class="nav-number">1.0.2.0.0.2.</span> <span class="nav-text">justify-content:</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#flex-start（默认值）：左对齐"><span class="nav-number">1.0.2.0.0.3.</span> <span class="nav-text">flex-start（默认值）：左对齐</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#align-items："><span class="nav-number">1.0.2.0.0.4.</span> <span class="nav-text">align-items：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#flex-start：交叉轴的起点对齐"><span class="nav-number">1.0.2.0.0.5.</span> <span class="nav-text">flex-start：交叉轴的起点对齐</span></a></li></ol></li></ol></li></ol><li class="nav-item nav-level-3"><a class="nav-link" href="#3、px为什么是双数"><span class="nav-number">1.0.3.</span> <span class="nav-text">3、px为什么是双数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4、css选择器有哪些-优先级"><span class="nav-number">1.0.4.</span> <span class="nav-text">4、css选择器有哪些?优先级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5、什么是BFC"><span class="nav-number">1.0.5.</span> <span class="nav-text">5、什么是BFC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6、常见页面布局"><span class="nav-number">1.0.6.</span> <span class="nav-text">6、常见页面布局</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7、响应式布局，xs，sm，md，lg对应的分辨率"><span class="nav-number">1.0.7.</span> <span class="nav-text">7、响应式布局，xs，sm，md，lg对应的分辨率</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8、css预处理器用过没，缺点是是什么，好处是什么"><span class="nav-number">1.0.8.</span> <span class="nav-text">8、css预处理器用过没，缺点是是什么，好处是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9、css3新特性有哪些？说个4-5个"><span class="nav-number">1.0.9.</span> <span class="nav-text">9、css3新特性有哪些？说个4-5个</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10、display和visbility区别"><span class="nav-number">1.0.10.</span> <span class="nav-text">10、display和visbility区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11、相邻的两个inline-block节点为什么会出现间隔，该如何解决"><span class="nav-number">1.0.11.</span> <span class="nav-text">11、相邻的两个inline-block节点为什么会出现间隔，该如何解决</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12、rem布局的优缺点"><span class="nav-number">1.0.12.</span> <span class="nav-text">12、rem布局的优缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13、CSS画三角形"><span class="nav-number">1.0.13.</span> <span class="nav-text">13、CSS画三角形</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14、1像素边框问题"><span class="nav-number">1.0.14.</span> <span class="nav-text">14、1像素边框问题</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#box-shadow-实现"><span class="nav-number">1.0.14.0.0.1.</span> <span class="nav-text">box-shadow 实现</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#transform-scale-0-5-实现-推荐相当灵活"><span class="nav-number">1.0.14.0.0.2.</span> <span class="nav-text">transform: scale(0.5) 实现 推荐相当灵活</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#html"><span class="nav-number">2.</span> <span class="nav-text">html</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、语义化"><span class="nav-number">2.0.1.</span> <span class="nav-text">1、语义化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、新标签新特性"><span class="nav-number">2.0.2.</span> <span class="nav-text">2、新标签新特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3、处理过哪些兼容性问题"><span class="nav-number">2.0.3.</span> <span class="nav-text">3、处理过哪些兼容性问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4、做过哪些性能优化"><span class="nav-number">2.0.4.</span> <span class="nav-text">4、做过哪些性能优化</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#js"><span class="nav-number">3.</span> <span class="nav-text">js</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、原型-原型链-构造函数-实例-继承"><span class="nav-number">3.0.1.</span> <span class="nav-text">1、原型/原型链/构造函数/实例/继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、有几种方式可以实现继承"><span class="nav-number">3.0.2.</span> <span class="nav-text">2、有几种方式可以实现继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3、用原型实现继承有什么缺点，怎么解决"><span class="nav-number">3.0.3.</span> <span class="nav-text">3、用原型实现继承有什么缺点，怎么解决</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4、arguments是什么？怎么用"><span class="nav-number">3.0.4.</span> <span class="nav-text">4、arguments是什么？怎么用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5、判断对象，数组，基本数据类型"><span class="nav-number">3.0.5.</span> <span class="nav-text">5、判断对象，数组，基本数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6、作用域链、闭包、作用域"><span class="nav-number">3.0.6.</span> <span class="nav-text">6、作用域链、闭包、作用域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7、Ajax的原生写法"><span class="nav-number">3.0.7.</span> <span class="nav-text">7、Ajax的原生写法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8、对象深拷贝、浅拷贝"><span class="nav-number">3.0.8.</span> <span class="nav-text">8、对象深拷贝、浅拷贝</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#深拷贝"><span class="nav-number">3.0.8.0.0.1.</span> <span class="nav-text">深拷贝:</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#浅拷贝："><span class="nav-number">3.0.8.0.0.2.</span> <span class="nav-text">浅拷贝：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#for-in-遍历赋值"><span class="nav-number">3.0.8.0.0.3.</span> <span class="nav-text">for in 遍历赋值</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9、图片懒加载原理"><span class="nav-number">3.0.9.</span> <span class="nav-text">9、图片懒加载原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10、实现页面加载进度条"><span class="nav-number">3.0.10.</span> <span class="nav-text">10、实现页面加载进度条</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11、this指向"><span class="nav-number">3.0.11.</span> <span class="nav-text">11、this指向</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12、为什么会有同源策略"><span class="nav-number">3.0.12.</span> <span class="nav-text">12、为什么会有同源策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13、怎么判断两个对象是否相等"><span class="nav-number">3.0.13.</span> <span class="nav-text">13、怎么判断两个对象是否相等</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14、事件委托是什么"><span class="nav-number">3.0.14.</span> <span class="nav-text">14、事件委托是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15、window的onload事件和domcontentloaded区别"><span class="nav-number">3.0.15.</span> <span class="nav-text">15、window的onload事件和domcontentloaded区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16、call-apply-bind区别"><span class="nav-number">3.0.16.</span> <span class="nav-text">16、call  apply  bind区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17、async-await用过吗？ES7新语法"><span class="nav-number">3.0.17.</span> <span class="nav-text">17、async/await用过吗？ES7新语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18、立即执行函数和使用场景"><span class="nav-number">3.0.18.</span> <span class="nav-text">18、立即执行函数和使用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19、数组去重，至少说一种ES6新增方法"><span class="nav-number">3.0.19.</span> <span class="nav-text">19、数组去重，至少说一种ES6新增方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20、BOM属性对象方法"><span class="nav-number">3.0.20.</span> <span class="nav-text">20、BOM属性对象方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21、垃圾回收机制"><span class="nav-number">3.0.21.</span> <span class="nav-text">21、垃圾回收机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22、JS执行机制"><span class="nav-number">3.0.22.</span> <span class="nav-text">22、JS执行机制</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ES6"><span class="nav-number">4.</span> <span class="nav-text">ES6</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、声明-let、const、var区别"><span class="nav-number">4.0.1.</span> <span class="nav-text">1、声明 let、const、var区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、解构赋值怎么用"><span class="nav-number">4.0.2.</span> <span class="nav-text">2、解构赋值怎么用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3、Promise的使用与实现"><span class="nav-number">4.0.3.</span> <span class="nav-text">3、Promise的使用与实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4、箭头函数this指向问题、拓展运算符"><span class="nav-number">4.0.4.</span> <span class="nav-text">4、箭头函数this指向问题、拓展运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5、map和set有没有用过，如何实现一个数组去重，map数据结构有什么优点？"><span class="nav-number">4.0.5.</span> <span class="nav-text">5、map和set有没有用过，如何实现一个数组去重，map数据结构有什么优点？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6、ES6怎么编译成ES5"><span class="nav-number">4.0.6.</span> <span class="nav-text">6、ES6怎么编译成ES5</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#浏览器"><span class="nav-number">5.</span> <span class="nav-text">浏览器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、输入url到展示页面过程发生了什么？"><span class="nav-number">5.0.1.</span> <span class="nav-text">1、输入url到展示页面过程发生了什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、重绘与回流"><span class="nav-number">5.0.2.</span> <span class="nav-text">2、重绘与回流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3、函数防抖与节流"><span class="nav-number">5.0.3.</span> <span class="nav-text">3、函数防抖与节流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4、cookies、session、sessionStorage、localStorage区别"><span class="nav-number">5.0.4.</span> <span class="nav-text">4、cookies、session、sessionStorage、localStorage区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5、浏览器内核"><span class="nav-number">5.0.5.</span> <span class="nav-text">5、浏览器内核</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#服务端与网络"><span class="nav-number">6.</span> <span class="nav-text">服务端与网络</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、常见状态码"><span class="nav-number">6.0.1.</span> <span class="nav-text">1、常见状态码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、缓存"><span class="nav-number">6.0.2.</span> <span class="nav-text">2、缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3、cookie-session-token"><span class="nav-number">6.0.3.</span> <span class="nav-text">3、cookie, session, token</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4、cdn托管是什么"><span class="nav-number">6.0.4.</span> <span class="nav-text">4、cdn托管是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5、get-post区别"><span class="nav-number">6.0.5.</span> <span class="nav-text">5、get post区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6、tcp三次握手，四次挥手流程"><span class="nav-number">6.0.6.</span> <span class="nav-text">6、tcp三次握手，四次挥手流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7、跨域有几种？"><span class="nav-number">6.0.7.</span> <span class="nav-text">7、跨域有几种？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-JSONP原理"><span class="nav-number">6.0.7.0.1.</span> <span class="nav-text">1.JSONP原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-CORS原理"><span class="nav-number">6.0.7.0.2.</span> <span class="nav-text">1.CORS原理</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#处理跨域方法三——WebSocket"><span class="nav-number">6.0.7.1.</span> <span class="nav-text">处理跨域方法三——WebSocket</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#处理跨域方法四——postMessage"><span class="nav-number">6.0.7.2.</span> <span class="nav-text">处理跨域方法四——postMessage</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8、前端安全XSS、CSRF，了解一下"><span class="nav-number">6.0.8.</span> <span class="nav-text">8、前端安全XSS、CSRF，了解一下</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9、模块化，commonJS，es6，cmd，amd"><span class="nav-number">6.0.9.</span> <span class="nav-text">9、模块化，commonJS，es6，cmd，amd</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Vue"><span class="nav-number">7.</span> <span class="nav-text">Vue</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、vue-单页面应用程序-和多页面应用程序的区别，优缺点"><span class="nav-number">7.0.1.</span> <span class="nav-text">1、vue(单页面应用程序)和多页面应用程序的区别，优缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多页面应用程序就是咱们写的普通页面，通过a标签实现页面切换，每次切换页面都要重新加载公共资源部分"><span class="nav-number">7.1.</span> <span class="nav-text">多页面应用程序就是咱们写的普通页面，通过a标签实现页面切换，每次切换页面都要重新加载公共资源部分</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2、MVVM的理解"><span class="nav-number">7.1.1.</span> <span class="nav-text">2、MVVM的理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3、如何实现一个自定义组件，不同组件之间如何通信的？"><span class="nav-number">7.1.2.</span> <span class="nav-text">3、如何实现一个自定义组件，不同组件之间如何通信的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4、nextTick"><span class="nav-number">7.1.3.</span> <span class="nav-text">4、nextTick</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5、生命周期"><span class="nav-number">7.1.4.</span> <span class="nav-text">5、生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6、虚拟dom的原理"><span class="nav-number">7.1.5.</span> <span class="nav-text">6、虚拟dom的原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7、双向绑定的原理？"><span class="nav-number">7.1.6.</span> <span class="nav-text">7、双向绑定的原理？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#数据劫持"><span class="nav-number">7.1.6.1.</span> <span class="nav-text">数据劫持</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8、组件通信"><span class="nav-number">7.1.7.</span> <span class="nav-text">8、组件通信</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10、watch-computed区别"><span class="nav-number">7.1.8.</span> <span class="nav-text">10、watch   computed区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12、vue-router原理"><span class="nav-number">7.1.9.</span> <span class="nav-text">12、vue-router原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13、vuex的理解，有哪些属性？actions和mutations区别？"><span class="nav-number">7.1.10.</span> <span class="nav-text">13、vuex的理解，有哪些属性？actions和mutations区别？</span></a></li></ol></li></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lanyangliu</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lanyangliu.io/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lanyangliu.io/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lanyangliu.io/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lanyangliu.io/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lanyangliu.io/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lanyangliu.io/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lanyangliu.io/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/lanyangliu.io/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/lanyangliu.io/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/lanyangliu.io/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/lanyangliu.io/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/lanyangliu.io/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/lanyangliu.io/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/lanyangliu.io/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  


<script src="/lanyangliu.io/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/lanyangliu.io/live2dw/assets/z16.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
